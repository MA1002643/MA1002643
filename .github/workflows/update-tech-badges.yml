name: Update tech badges

on:
  schedule:
    - cron: "0 9 * * 1" # Mondays 09:00 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-badges:
    runs-on: ubuntu-latest
    env:
      # Use a PAT with `repo` scope to include private repos
      GH_TOKEN: ${{ secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}
      REPO_OWNER: ${{ github.repository_owner }}
      README_PATH: README.md
      BADGE_STYLE: "for-the-badge"
      LANG_START: "<!-- LANG-ICONS:START -->"
      LANG_END: "<!-- LANG-ICONS:END -->"
      FWLIB_START: "<!-- FWLIB-ICONS:START -->"
      FWLIB_END: "<!-- FWLIB-ICONS:END -->"
      DBCLOUD_START: "<!-- DBCLOUD-ICONS:START -->"
      DBCLOUD_END: "<!-- DBCLOUD-ICONS:END -->"
      TOOLS_START: "<!-- TOOLS-ICONS:START -->"
      TOOLS_END: "<!-- TOOLS-ICONS:END -->"

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Simple Icons (for brand colors)
        run: npm i simple-icons@^13

      - name: Deep-scan repos and update README badges
        run: |
          node - <<'NODE'
          const fs = require('fs');

          const {
            GH_TOKEN, REPO_OWNER, README_PATH, BADGE_STYLE,
            LANG_START, LANG_END, FWLIB_START, FWLIB_END,
            DBCLOUD_START, DBCLOUD_END, TOOLS_START, TOOLS_END
          } = process.env;

          if (!GH_TOKEN) { console.error('❌ Missing GH_TOKEN'); process.exit(1); }
          if (!fs.existsSync(README_PATH)) { console.error(`❌ Missing ${README_PATH}`); process.exit(1); }

          // ---------- HTTP helpers ----------
          const fetchJSON = async (url, headers={}) => {
            const res = await fetch(url, { headers });
            if (!res.ok) throw new Error(`${res.status} ${url}: ${await res.text()}`);
            return res.json();
          };
          const GQL = async (query, variables) => {
            const res = await fetch('https://api.github.com/graphql', {
              method:'POST',
              headers:{ Authorization:`bearer ${GH_TOKEN}`, 'Content-Type':'application/json', 'Accept':'application/vnd.github+json' },
              body: JSON.stringify({ query, variables })
            });
            if (!res.ok) throw new Error(`GraphQL ${res.status}: ${await res.text()}`);
            const j = await res.json();
            if (j.errors) throw new Error(JSON.stringify(j.errors));
            return j.data;
          };
          const REST = (u) => fetchJSON(u, { Authorization:`Bearer ${GH_TOKEN}`, 'Accept':'application/vnd.github+json' });

          // ---------- Merge helper (preserve existing badges) ----------
          function mergeSection(readme, start, end, badges) {
            const si = readme.indexOf(start), ei = readme.indexOf(end);
            if (si === -1 || ei === -1 || ei < si) throw new Error(`Markers not found: ${start} / ${end}`);
            const before = readme.slice(0, si + start.length);
            const between = readme.slice(si + start.length, ei);
            const after = readme.slice(ei);
            const existing = between.trim();
            const existingBadges = (existing.match(/!\[[^\]]*\]\([^)]+\)/g)||[]).map(s=>s.trim());
            const existingLabels = new Set(existingBadges.map(b => (b.match(/!\[([^\]]+)\]/)||[])[1]).filter(Boolean));
            const filtered = badges.filter(b => {
              const m = b.match(/!\[([^\]]+)\]/); const lbl = m && m[1];
              return lbl && !existingLabels.has(lbl);
            });
            const next = ['\n', existing, existing?'\n':'', filtered.join('\n'), '\n'].join('');
            return before + next + after;
          }

          // ---------- Auto Simple-Icons color + slug (compact + encoded) ----------
          async function buildBadgeFn() {
            const SI = await import('simple-icons'); // ESM with .get(slug)

            const normalize = (s) =>
              s.normalize('NFKD')
               .replace(/[\u0300-\u036f]/g, '')
               .toLowerCase()
               .trim();

            // Generate slug candidates (compact, space-free first)
            function candidatesFor(label) {
              const raw = normalize(label);
              const compact = (x) => x.replace(/[\s._-]+/g, '');
              const noDots  = (x) => x.replace(/\./g, '');
              const andFix  = (x) => x.replace(/&/g, 'and');
              const plusFix = (x) => x.replace(/\+/g, 'plus');

              let base = raw;
              base = base.replace(/\bc\+\+\b/g, 'cplusplus');
              base = base.replace(/\bc#\b/g, 'csharp');
              base = base.replace(/(^|\W)\.net(\W|$)/g, '$1dotnet$2');
              base = base.replace(/node\.?\s*js\b/g, 'nodedotjs');
              base = base.replace(/next\.?\s*js\b/g, 'nextdotjs');
              base = base.replace(/three\.?\s*js\b/g, 'threedotjs');
              base = base.replace(/angular\.?\s*js\b/g, 'angularjs');
              base = base.replace(/\bvs\s*code\b/g, 'visualstudiocode');
              base = base.replace(/\bvisual\s*studio\s*code\b/g, 'visualstudiocode');
              base = base.replace(/\bmicrosoft\s*azure\b/g, 'microsoftazure');
              base = base.replace(/\bazure\s*dev\s*ops\b/g, 'azuredevops');
              base = base.replace(/\bgoogle\s*cloud\b/g, 'googlecloud');
              base = base.replace(/\bgcp\b/g, 'googlecloud');
              base = base.replace(/\bamazon\s*web\s*services\b/g, 'amazonaws');

              const forms = [];
              const add = (s) => { if (s && !forms.includes(s)) forms.push(s); };

              // compact first (prevents broken logos with spaces)
              add(compact(base));
              add(compact(andFix(base)));
              add(compact(plusFix(base)));
              add(compact(noDots(base)));
              add(compact(andFix(noDots(base))));
              add(compact(plusFix(noDots(base))));

              // fallbacks (rarely used)
              add(base);
              add(andFix(base));
              add(plusFix(base));
              add(noDots(base));
              add(andFix(noDots(base)));
              add(plusFix(noDots(base)));

              return forms;
            }

            function brandHexFor(label) {
              for (const slug of candidatesFor(label)) {
                const icon = SI.get?.(slug);
                if (icon?.hex) return icon.hex;
              }
              if (typeof COLOR_MAP !== 'undefined' && COLOR_MAP[label]) return COLOR_MAP[label];
              return '444444';
            }

            return (label, preferredHex) => {
              let logoSlug = null;
              for (const slug of candidatesFor(label)) {
                const icon = SI.get?.(slug);
                if (icon) { logoSlug = slug; break; }
              }
              if (!logoSlug) {
                const compactFallback = normalize(label)
                  .replace(/&/g, 'and')
                  .replace(/\+/g, 'plus')
                  .replace(/[\s._-]+/g, '')
                  .replace(/\./g, '');
                logoSlug = compactFallback || 'generic';
              }

              const encLabel = encodeURIComponent(label);
              const encLogo  = encodeURIComponent(logoSlug); // avoid broken badges
              const hex = (preferredHex || brandHexFor(label)).replace(/^#/, '');

              return `![${label}](https://img.shields.io/badge/${encLabel}-${hex}?style=${BADGE_STYLE}&logo=${encLogo}&logoColor=white)`;
            };
          }

          // ---------- Minimal fallback colors (used only if icon not found) ----------
          const COLOR_MAP = {
            "Python":"3776AB","JavaScript":"F7DF1E","TypeScript":"3178C6","HTML5":"E34F26","CSS3":"1572B6",
            "Java":"007396","C#":"239120","C++":"00599C","Go":"00ADD8","Rust":"000000","SQL":"4479A1",
            "MySQL":"4479A1","SQLite":"003B57","MongoDB":"47A248","Redis":"DC382D",
            "Git":"F05032","GitHub":"181717","Postman":"FF6C37","Ubuntu":"E95420","VS Code":"007ACC","Visual Studio":"5C2D91"
          };

          // ---------- Repo listing & tree scan ----------
          const REPO_QUERY = `
            query($owner:String!, $after:String){
              repositoryOwner(login:$owner){
                repositories(first:100, ownerAffiliations: OWNER, after:$after, orderBy:{field:UPDATED_AT, direction:DESC}){
                  pageInfo{ hasNextPage endCursor }
                  nodes{
                    nameWithOwner
                    defaultBranchRef { name target { ... on Commit { oid } } }
                    languages(first:100, orderBy:{field:SIZE, direction:DESC}){ edges{ size, node{ name } } }
                  }
                }
              }
            }`;

          const FILE_PATTERNS = [
            /(^|\/)package\.json$/i, /(^|\/)pnpm\-lock\.yaml$/i, /(^|\/)yarn\.lock$/i, /(^|\/)package\-lock\.json$/i,
            /(^|\/)requirements\.txt$/i, /(^|\/)pyproject\.toml$/i, /(^|\/)Pipfile$/i, /(^|\/)Pipfile\.lock$/i,
            /(^|\/)go\.mod$/i, /(^|\/)Cargo\.toml$/i,
            /(^|\/)pom\.xml$/i, /(^|\/)build\.gradle(\.kts)?$/i, /(^|\/)settings\.gradle(\.kts)?$/i,
            /(^|\/)composer\.json$/i, /(^|\/)composer\.lock$/i, /(^|\/)Gemfile(\.lock)?$/i,
            /\.csproj$/i, /\.vbproj$/i, /\.fsproj$/i, /(^|\/)Directory\.Packages\.props$/i, /\.sln$/i, /(^|\/)packages\.config$/i,
            /(^|\/)pubspec\.yaml$/i,
            /(^|\/)Package\.swift$/i, /(^|\/)Podfile(\.lock)?$/i, /(^|\/)Cartfile(\.resolved)?$/i,
            /(^|\/)mix\.exs$/i, /(^|\/)rebar\.config$/i,
            /\.cabal$/i, /(^|\/)stack\.yaml$/i,
            /(^|\/)DESCRIPTION$/i, /(^|\/)Project\.toml$/i,
            /\.tf$/i, /(^|\/)requirements\.yml$/i, /(^|\/)Chart\.yaml$/i, /\.ya?ml$/i,
            /(^|\/)Dockerfile$/i, /(^|\/)docker\-compose\.ya?ml$/i,
            /(^|\/)serverless\.ya?ml$/i, /(^|\/)vercel\.json$/i, /(^|\/)netlify\.toml$/i, /(^|\/)render\.ya?ml$/i,
            /(^|\/)railway\.json$/i, /(^|\/)fly\.toml$/i, /(^|\/)heroku\.ya?ml$/i,
            /(^|\/)azure\-pipelines\.ya?ml$/i, /(^|\/)README(\.md|\.rst|\.adoc)?$/i
          ];

          // Keyword detectors: names are lowercased keys → nice labels
          const FWLIB_KW = {
            "react":"React","next":"Next.js","vue":"Vue.js","nuxt":"Nuxt","svelte":"Svelte","astro":"Astro","solid":"SolidJS",
            "angular":"Angular","redux":"Redux","zustand":"Zustand","express":"Express","fastify":"Fastify","koa":"Koa",
            "hapi":"hapi","nestjs":"NestJS","tailwindcss":"Tailwind CSS","bootstrap":"Bootstrap","@mui/material":"MUI",
            "mantine":"Mantine","chakra-ui":"Chakra UI","antd":"Ant Design","daisyui":"daisyUI","three":"Three.js",
            "framer-motion":"Framer Motion","vite":"Vite","webpack":"Webpack","rollup":"Rollup","parcel":"Parcel",
            "electron":"Electron","expo":"Expo",
            "django":"Django","flask":"Flask","fastapi":"FastAPI","pydantic":"Pydantic","jinja2":"Jinja2",
            "numpy":"NumPy","pandas":"Pandas","matplotlib":"Matplotlib","scikit-learn":"scikit-learn","tensorflow":"TensorFlow",
            "torch":"PyTorch","pytorch":"PyTorch","scrapy":"Scrapy","streamlit":"Streamlit",
            "spring":"Spring","spring-boot":"Spring Boot","quarkus":"Quarkus","micronaut":"Micronaut",
            "laravel":"Laravel","symfony":"Symfony","rails":"Ruby on Rails","sinatra":"Sinatra",
            "gin":"Gin","echo":"Echo","fiber":"Fiber","gorm":"GORM",
            "flutter":"Flutter","bloc":"BLoC","riverpod":"Riverpod","get_it":"GetIt",
            "aspnetcore":"ASP.NET Core","entityframework":"Entity Framework","serilog":"Serilog","autofac":"Autofac",
            "rocket":"Rocket","actix-web":"Actix Web","phoenix":"Phoenix","vapor":"Vapor"
          };

          const DB_KW = {
            "mongoose":"Mongoose","prisma":"Prisma","sequelize":"Sequelize","typeorm":"TypeORM","drizzle-orm":"Drizzle ORM",
            "mysql":"MySQL","mysql2":"MySQL","pg":"PostgreSQL","postgres":"PostgreSQL","psycopg2":"PostgreSQL",
            "sqlite":"SQLite","sqlite3":"SQLite","better-sqlite3":"SQLite","oracledb":"Oracle DB","mssql":"SQL Server",
            "redis":"Redis","ioredis":"ioredis","memcached":"Memcached","mongodb":"MongoDB","pymongo":"MongoDB",
            "@aws-sdk/":"AWS SDK (JS)","aws-sdk":"AWS SDK","boto3":"AWS SDK (Py)","firebase":"Firebase",
            "@google-cloud/storage":"Google Cloud Storage","@google-cloud/firestore":"Firestore","@google-cloud/pubsub":"Pub/Sub",
            "@azure/storage-blob":"Azure Blob Storage","@azure/cosmos":"Azure Cosmos DB","supabase":"Supabase","appwrite":"Appwrite",
            "dynamoose":"DynamoDB","@aws-sdk/client-dynamodb":"DynamoDB","pocketbase":"PocketBase"
          };

          const CLOUD_CFG_HINTS = {
            "vercel.json":"Vercel","netlify.toml":"Netlify","render.yaml":"Render","railway.json":"Railway",
            "fly.toml":"Fly.io","heroku.yml":"Heroku","serverless.yml":"Serverless Framework","serverless.yaml":"Serverless Framework"
          };

          const TOOLS_KW = {
            "eslint":"ESLint","prettier":"Prettier","jest":"Jest","vitest":"Vitest","cypress":"Cypress","playwright":"Playwright",
            "mocha":"Mocha","chai":"Chai","husky":"Husky","lint-staged":"lint-staged","commitlint":"commitlint","commitizen":"Commitizen",
            "ts-node":"TS Node","typescript":"TypeScript","nodemon":"Nodemon","pm2":"PM2","storybook":"Storybook","nyc":"nyc/Istanbul",
            "babel":"Babel","tsup":"tsup","esbuild":"esbuild","webpack":"Webpack","vite":"Vite","turbo":"Turborepo",
            "pytest":"pytest","black":"Black","flake8":"Flake8","ruff":"Ruff","mypy":"mypy","tox":"tox","pipenv":"Pipenv",
            "docker":"Docker","docker-compose":"Docker Compose","make":"Make","helm":"Helm","terraform":"Terraform","ansible":"Ansible",
            "serilog":"Serilog","xunit":"xUnit","nunit":"NUnit","coverlet":"Coverlet","maven":"Maven","gradle":"Gradle","fastlane":"fastlane",
            "rspec":"RSpec","rubocop":"RuboCop","phpunit/phpunit":"PHPUnit","phpstan/phpstan":"PHPStan","friendsofphp/php-cs-fixer":"PHP CS Fixer",
            "msbuild":"MSBuild","nuget":"NuGet","yarn":"Yarn","npm":"npm","pnpm":"pnpm"
          };

          // Must-include (guaranteed to appear)
          const ALWAYS_LANGS = [
            "C#","Java","JavaScript (ES6+)","SQL","Python","HTML5","CSS3",
            "Prolog","Haskell","C++","Go","Rust","MIPS Assembly"
          ];
          const ALWAYS_FWLIB = [
            ".NET","Blazor",".NET MAUI","Node.js","Express.js","React","Vue.js","Next.js","Tailwind CSS","Three.js","Angular.js"
          ];
          const ALWAYS_DBCLOUD = ["MySQL","SQLite"];
          const ALWAYS_TOOLS = [
            "Git","GitHub","Azure DevOps","Jira","Tomcat","Postman","Visual Studio","VS Code","Photoshop","Ubuntu",
            "Software Design & Architecture","UML","Testing","JUnit","NUnit","Unit","Integration","System",
            "CI/CD","DevOps automation","UX Design","Database Integration","Project Management","TypeScript","TS Node",
            "Docker Compose","ESLint","Husky","Make","MSBuild","NPM","nyc/Istanbul","Webpack","Yarn","Vite","Babel","Mocha","Chai","Nodemon","NuGet","PHPUnit","Prettier","commitlint","lint-staged","Commitizen"
          ];

          // ---------- Parsers ----------
          const parseJSON = t => { try { return JSON.parse(t); } catch { return null; } };
          const parseRequirements = t => (t||'').split(/\r?\n/).map(l=>l.trim()).filter(l=>l && !l.startsWith('#'))
            .map(l=>l.split(/[\s<>=!~\[]/,1)[0].toLowerCase());
          const parsePipfileLock = t => { const j = parseJSON(t) || {}; return Object.keys({...(j.default||{}), ...(j.develop||{})}).map(s=>s.toLowerCase()); };
          const parseGoMod = t => (t||'').split(/\r?\n/).map(l=>{
            let m = l.match(/^\s*require\s+([^\s]+)\s+/) || l.match(/^\s*([^\s]+)\s+v\d/); return m?m[1].toLowerCase():null;
          }).filter(Boolean);
          const parseCargoToml = t => (t||'').toLowerCase().split(/\r?\n/)
            .map(l=>{ const m=l.match(/^\s*([a-z0-9_.-]+)\s*=\s*["{\[]/); return m?m[1]:null; }).filter(Boolean);
          const parsePomXml = t => (t||'').toLowerCase().match(/<artifactid>([^<]+)<\/artifactid>/g)?.map(s=>s.replace(/<\/?artifactid>/g,'')).filter(Boolean) || [];
          const parseGradle = t => (t||'').toLowerCase().match(/['"]([a-z0-9_.-]+):([a-z0-9_.-]+)['"]/g)?.map(s=>s.replace(/['"]/g,'')).map(s=>s.split(':')[0]) || [];
          const parseComposer = t => { const j = parseJSON(t); const b = j? {...(j.require||{}), ...(j['require-dev']||{})} : {}; return Object.keys(b).map(s=>s.toLowerCase()); };
          const parseGemfile = t => { const out=[]; for (const m of (t||'').toLowerCase().matchAll(/gem\s+['"]([^'"]+)['"]/g)) out.push(m[1]); return out; };
          const parseCsproj = t => {
            const s=(t||'').toLowerCase(); const libs=[];
            if (/usemaui\s*>\s*true/.test(s) || /microsoft\.maui/.test(s)) libs.push('.NET MAUI');
            if (/microsoft\.aspnetcore\.components|razor/.test(s)) libs.push('Blazor');
            if (/entityframework/.test(s)) libs.push('Entity Framework');
            if (/serilog/.test(s)) libs.push('Serilog');
            return libs;
          };
          const parsePubspec = t => {
            const out = new Set(); const s=(t||'').toLowerCase();
            out.add('Flutter'); if (/cloud_firestore\s*:/.test(s)) out.add('Firestore');
            if (/firebase_core\s*:/.test(s)) out.add('Firebase'); if (/sqflite\s*:/.test(s)) out.add('SQLite');
            if (/\bbloc\s*:/.test(s)) out.add('BLoC'); if (/\briverpod\s*:/.test(s)) out.add('Riverpod'); return [...out];
          };
          const parseSwiftPM = t => /vapor/i.test(t||'') ? ['Vapor'] : [];
          const parseTerraform = t => {
            const set = new Set(); const s=(t||'').toLowerCase();
            if (/provider\s+"aws"/.test(s)) set.add('AWS'); if (/provider\s+"google"/.test(s)) set.add('Google Cloud');
            if (/provider\s+"azurerm"/.test(s)) set.add('Azure'); return [...set];
          };

          // ---------- Repo listing ----------
          async function listAllRepos(owner){
            const all=[]; let after=null;
            while(true){
              const data = await GQL(REPO_QUERY, { owner, after });
              const repos = data?.repositoryOwner?.repositories; if (!repos) break;
              all.push(...repos.nodes); if (!repos.pageInfo.hasNextPage) break; after = repos.pageInfo.endCursor;
            }
            return all;
          }
          async function getTree(ownerRepo, sha){
            const [owner, repo] = ownerRepo.split('/');
            return await REST(`https://api.github.com/repos/${owner}/${repo}/git/trees/${sha}?recursive=1`);
          }
          async function getContent(ownerRepo, filePath){
            const [owner, repo] = ownerRepo.split('/');
            const j = await REST(`https://api.github.com/repos/${owner}/${repo}/contents/${encodeURIComponent(filePath)}`);
            if (Array.isArray(j)) return null;
            if (j.encoding === 'base64' && j.content) return Buffer.from(j.content,'base64').toString('utf8');
            return j.content || '';
          }

          // ---------- Accumulators ----------
          const langTotals = new Map();
          const fwlib = new Set();
          const dbcloud = new Set();
          const tools = new Set();

          (async () => {
            // Create ONCE and reuse (fixes redeclare error)
            const makeBadge = await buildBadgeFn();

            const repos = await listAllRepos(REPO_OWNER);

            // Languages via Linguist
            for (const repo of repos) {
              for (const e of (repo.languages?.edges || [])) {
                const lang = e.node.name; const size = e.size||0;
                langTotals.set(lang, (langTotals.get(lang)||0)+size);
              }
            }

            // Walk trees & parse files
            for (const repo of repos) {
              const oid = repo.defaultBranchRef?.target?.oid;
              if (!oid) continue;

              let tree;
              try { tree = await getTree(repo.nameWithOwner, oid); } catch { continue; }
              if (!tree || !Array.isArray(tree.tree)) continue;

              const files = tree.tree.filter(it => it.type === 'blob' && FILE_PATTERNS.some(rx => rx.test(it.path)));

              for (const it of files) {
                const p = it.path; const lower = p.toLowerCase();
                let txt = '';
                try { txt = await getContent(repo.nameWithOwner, p); } catch { continue; }

                // JS/TS
                if (lower.endsWith('package.json')) {
                  const j = parseJSON(txt) || {};
                  const buckets = [j.dependencies, j.devDependencies, j.peerDependencies, j.optionalDependencies];
                  for (const b of buckets) if (b) for (const [name] of Object.entries(b)) {
                    const n = name.toLowerCase();
                    for (const k of Object.keys(FWLIB_KW)) if (n === k || n.startsWith(k)) fwlib.add(FWLIB_KW[k]);
                    for (const k of Object.keys(DB_KW)) if (n === k || n.startsWith(k)) dbcloud.add(DB_KW[k]);
                    for (const k of Object.keys(TOOLS_KW)) if (n === k || n.startsWith(k)) tools.add(TOOLS_KW[k]);
                    if (n === 'node' || n === 'nodejs') tools.add('Node.js');
                  }
                  for (const cmd of Object.values(j.scripts || {})) {
                    const c=String(cmd);
                    if (/eslint/.test(c)) tools.add('ESLint');
                    if (/prettier/.test(c)) tools.add('Prettier');
                    if (/jest/.test(c)) tools.add('Jest');
                    if (/cypress/.test(c)) tools.add('Cypress');
                    if (/playwright/.test(c)) tools.add('Playwright');
                    if (/vite/.test(c)) tools.add('Vite');
                    if (/webpack/.test(c)) tools.add('Webpack');
                    if (/turbo/.test(c)) tools.add('Turborepo');
                  }
                }
                if (lower.endsWith('pnpm-lock.yaml')) tools.add('pnpm');
                if (lower.endsWith('yarn.lock')) tools.add('Yarn');
                if (lower.endsWith('package-lock.json')) tools.add('npm');

                // Python
                if (lower.endsWith('requirements.txt')) {
                  for (const n of parseRequirements(txt)) {
                    if (FWLIB_KW[n]) fwlib.add(FWLIB_KW[n]);
                    if (DB_KW[n]) dbcloud.add(DB_KW[n]);
                    if (TOOLS_KW[n]) tools.add(TOOLS_KW[n]);
                  }
                }
                if (lower.endsWith('pyproject.toml')) {
                  const deps = (txt.match(/^\s*([a-z0-9_.-]+)\s*=\s*["'\[]/gmi)||[])
                    .map(line=>line.split('=')[0].trim().toLowerCase());
                  for (const n of deps) {
                    if (FWLIB_KW[n]) fwlib.add(FWLIB_KW[n]);
                    if (DB_KW[n]) dbcloud.add(DB_KW[n]);   // ✅ fixed typo
                    if (TOOLS_KW[n]) tools.add(TOOLS_KW[n]);
                  }
                }
                if (lower.endsWith('pipfile.lock')) {
                  for (const n of parsePipfileLock(txt)) {
                    if (FWLIB_KW[n]) fwlib.add(FWLIB_KW[n]);
                    if (DB_KW[n]) dbcloud.add(DB_KW[n]);
                    if (TOOLS_KW[n]) tools.add(TOOLS_KW[n]);
                  }
                }

                // Go / Rust
                if (lower.endsWith('go.mod')) {
                  for (const n of parseGoMod(txt)) {
                    if (n.includes('gin-gonic')) fwlib.add('Gin');
                    if (n.includes('gorm.io')) fwlib.add('GORM');
                  }
                }
                if (lower.endsWith('cargo.toml')) {
                  for (const n of parseCargoToml(txt)) {
                    if (n === 'rocket') fwlib.add('Rocket');
                    if (n === 'actix-web') fwlib.add('Actix Web');
                  }
                }

                // Java / Kotlin
                if (lower.endsWith('pom.xml')) {
                  const arts = parsePomXml(txt);
                  const t = (txt||'').toLowerCase();
                  if (/tomcat/.test(t)) tools.add('Tomcat');
                  if (/<artifactid>junit/.test(t)) tools.add('JUnit');
                  for (const g of arts) {
                    if (g.includes('spring-boot') || g.includes('springframework')) fwlib.add('Spring Boot');
                    tools.add('Maven');
                  }
                }
                if (/(^|\/)build\.gradle(\.kts)?$/i.test(lower) || /(^|\/)settings\.gradle(\.kts)?$/i.test(lower)) {
                  const t = (txt||'').toLowerCase();
                  if (/tomcat/.test(t)) tools.add('Tomcat');
                  if (/junit/.test(t)) tools.add('JUnit');
                  tools.add('Gradle');
                }

                // PHP / Ruby
                if (lower.endsWith('composer.json') || lower.endsWith('composer.lock')) {
                  for (const n of parseComposer(txt)) {
                    if (n === 'laravel/framework') fwlib.add('Laravel');
                    if (n.startsWith('symfony/')) fwlib.add('Symfony');
                    if (n === 'doctrine/orm') fwlib.add('Doctrine ORM');
                    if (n === 'mongodb/mongodb') dbcloud.add('MongoDB');
                    if (n === 'predis/predis') dbcloud.add('Redis');
                    if (n === 'phpunit/phpunit') tools.add('PHPUnit');
                    if (n === 'phpstan/phpstan') tools.add('PHPStan');
                    if (n === 'friendsofphp/php-cs-fixer') tools.add('PHP CS Fixer');
                  }
                }
                if (/gemfile(\.lock)?$/i.test(lower)) {
                  for (const n of parseGemfile(txt)) {
                    if (n === 'rails') fwlib.add('Ruby on Rails');
                    if (n === 'sinatra') fwlib.add('Sinatra');
                    if (n === 'pg') dbcloud.add('PostgreSQL');
                    if (n === 'mysql2') dbcloud.add('MySQL');
                    if (n === 'rspec') tools.add('RSpec');
                    if (n === 'rubocop') tools.add('RuboCop');
                  }
                }

                // .NET
                if (/\.(csproj|vbproj|fsproj)$/i.test(lower) || /(^|\/)directory\.packages\.props$/i.test(lower)) {
                  for (const n of parseCsproj(txt)) fwlib.add(n);
                  tools.add('NuGet');
                }
                if (/\.sln$/i.test(lower)) tools.add('MSBuild');

                // Dart / Flutter
                if (lower.endsWith('pubspec.yaml')) {
                  for (const n of parsePubspec(txt)) fwlib.add(n);
                }

                // Swift
                if (lower.endsWith('package.swift')) for (const n of parseSwiftPM(txt)) fwlib.add(n);
                if (/podfile(\.lock)?$/i.test(lower)) tools.add('CocoaPods');
                if (/cartfile(\.resolved)?$/i.test(lower)) tools.add('Carthage');

                // Elixir / Erlang
                if (lower.endsWith('mix.exs')) fwlib.add('Phoenix');
                if (lower.endsWith('rebar.config')) fwlib.add('Rebar');

                // Haskell
                if (/\.cabal$/i.test(lower)) tools.add('Cabal');
                if (lower.endsWith('stack.yaml')) tools.add('Stack');

                // R / Julia
                if (lower.endsWith('description')) fwlib.add('CRAN/R');
                if (lower.endsWith('project.toml')) fwlib.add('Julia Pkg');

                // Terraform / Ansible / Helm / K8s
                if (/\.tf$/i.test(lower)) { for (const cloud of parseTerraform(txt)) dbcloud.add(cloud); tools.add('Terraform'); }
                if (/(^|\/)requirements\.yml$/i.test(lower)) tools.add('Ansible');
                if (/(^|\/)chart\.yaml$/i.test(lower)) tools.add('Helm');
                if (/(^|\/).+\.ya?ml$/i.test(lower) && /apiVersion:\s*(v1|apps\/v1)/.test(txt)) tools.add('Kubernetes');

                // Containers
                if (/(^|\/)dockerfile$/i.test(lower)) { tools.add('Docker'); if (/tomcat/i.test(txt)) tools.add('Tomcat'); }
                if (/(^|\/)docker-compose\.ya?ml$/i.test(lower)) {
                  tools.add('Docker Compose');
                  const s = txt.toLowerCase();
                  if (/mongo/.test(s)) dbcloud.add('MongoDB');
                  if (/postgres/.test(s)) dbcloud.add('PostgreSQL');
                  if (/mysql/.test(s)) dbcloud.add('MySQL');
                  if (/redis/.test(s)) dbcloud.add('Redis');
                }

                // Cloud host configs
                for (const [fname, label] of Object.entries(CLOUD_CFG_HINTS)) {
                  if (lower.endsWith(fname.toLowerCase())) dbcloud.add(label);
                }

                // Misc signals
                if (/azure\-pipelines\.ya?ml$/i.test(lower)) tools.add('Azure DevOps');
                if (/(^|\/)README(\.md|\.rst|\.adoc)?$/i.test(lower)) {
                  const t=(txt||'').toLowerCase();
                  if (/\bunit test/.test(t)) tools.add('Unit');
                  if (/\bintegration test/.test(t)) tools.add('Integration');
                  if (/\bsystem test/.test(t)) tools.add('System');
                }
              }
            }

            // Normalize some language names
            const LANGUAGE_RENAMES = {
              "HTML":"HTML5","CSS":"CSS3","JavaScript":"JavaScript (ES6+)","Assembly":"MIPS Assembly",
              "C++":"C++","C#":"C#","Go":"Go","Rust":"Rust","Prolog":"Prolog","Haskell":"Haskell","SQL":"SQL"
            };

            // Must-include unions
            for (const l of ALWAYS_LANGS) langTotals.set(l, (langTotals.get(l)||0)+1);
            for (const f of ALWAYS_FWLIB) fwlib.add(f);
            for (const d of ALWAYS_DBCLOUD) dbcloud.add(d);
            for (const t of ALWAYS_TOOLS) tools.add(t);

            // Build badges with auto brand colors
            const langsSorted = [...langTotals.entries()]
              .sort((a,b)=>b[1]-a[1])
              .map(([l]) => LANGUAGE_RENAMES[l] || l);
            const fwlibSorted = [...fwlib].sort();
            const dbcloudSorted = [...dbcloud].sort();
            const toolsSorted = [...tools].sort();

            const langBadges = langsSorted.map(l => makeBadge(l));
            const fwlibBadges = fwlibSorted.map(l => makeBadge(l));
            const dbcloudBadges = dbcloudSorted.map(l => makeBadge(l));
            const toolsBadges = toolsSorted.map(l => makeBadge(l));

            // Update README
            let readme = fs.readFileSync(README_PATH, 'utf8');
            readme = mergeSection(readme, LANG_START, LANG_END, langBadges);
            readme = mergeSection(readme, FWLIB_START, FWLIB_END, fwlibBadges);
            readme = mergeSection(readme, DBCLOUD_START, DBCLOUD_END, dbcloudBadges);
            readme = mergeSection(readme, TOOLS_START, TOOLS_END, toolsBadges);
            fs.writeFileSync(README_PATH, readme, 'utf8');

            console.log('✅ README updated with auto Simple-Icons brand colors (no broken logos).');
          })().catch(e => { console.error('❌ Failed:', e); process.exit(1); });
          NODE

      - name: Commit & push
        env:
          PAT_OR_TOKEN: ${{ secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          if git diff --quiet; then
            echo "No changes."
            exit 0
          fi
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add "${README_PATH}"
          git commit -m "chore: refresh tech badges (deep scan, auto brand colors, slug fix)"
          git push https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:${GITHUB_REF_NAME:-main} || \
          git push https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:main || \
          git push https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git HEAD:master
