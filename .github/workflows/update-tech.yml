name: Auto-detect tech stack

on:
  schedule: [{ cron: "0 8 * * 1" }] # Monday 08:00 UTC
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  scan:
    runs-on: ubuntu-latest
    env:
      OWNER: MA1002643
      READ_ME: README.md
    steps:
      - uses: actions/checkout@v4

      # If you want to include PRIVATE repos, create a secret named TECH_PAT (repo scope)
      # and uncomment the next 3 lines + change the "github-token" input below.
      # - name: Use personal access token for private repos
      #   run: echo "USING_TECH_PAT=1" >> $GITHUB_ENV
      #   env: {}

      - name: Build & inject tech inventory
        uses: actions/github-script@v7
        with:
          # For public repos, this is enough:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          # If you enabled TECH_PAT above, switch to:
          # github-token: ${{ secrets.TECH_PAT }}
          script: |
            const fs = require('fs');

            const OWNER = process.env.OWNER || context.repo.owner;
            const READ_ME = process.env.READ_ME || 'README.md';

            // Manifests we scan (root only for speed/safety)
            const manifestPaths = [
              'package.json',
              'requirements.txt',
              'pyproject.toml',
              'pom.xml',
              'build.gradle',
              'build.gradle.kts',
              'Cargo.toml',
              'composer.json',
              'go.mod',
            ];

            // Normalization helper
            const normalize = (s) =>
              s.toLowerCase()
               .replace(/@.*$/,'')
               .replace(/[><=~^*].*$/,'')
               .replace(/\s+/g,'');

            const add = (set, arr) => arr.filter(Boolean).forEach(x => set.add(normalize(x)));

            // 1) List PUBLIC repos for OWNER
            const repos = await github.paginate(
              'GET /users/{username}/repos',
              { username: OWNER, per_page: 100, type: 'public', sort: 'updated' }
            );

            const tech = new Set();
            for (const r of repos) {
              const repo = r.name;
              const ref = r.default_branch || 'main';

              for (const path of manifestPaths) {
                try {
                  const { data } = await github.request(
                    'GET /repos/{owner}/{repo}/contents/{path}',
                    { owner: OWNER, repo, path, ref }
                  );
                  if (!data || data.type !== 'file' || !data.content) continue;
                  const text = Buffer.from(data.content, 'base64').toString('utf8');

                  if (path === 'package.json') {
                    try {
                      const j = JSON.parse(text);
                      add(tech, Object.keys(j.dependencies || {}));
                      add(tech, Object.keys(j.devDependencies || {}));
                    } catch {}
                  } else if (path === 'requirements.txt') {
                    const lines = text
                      .split(/\r?\n/)
                      .map(l => l.replace(/#.*/,'').trim())
                      .filter(Boolean)
                      .map(l => l.split(/[=<>~! ]/)[0]);
                    add(tech, lines);
                  } else if (path === 'pyproject.toml') {
                    const deps = [];
                    const seg = text.split('[tool.poetry.dependencies]')[1] || '';
                    for (const line of seg.split(/\r?\n/)) {
                      if (/^\[.+\]/.test(line)) break;
                      const k = line.split('=')[0]?.trim();
                      if (k) deps.push(k);
                    }
                    add(tech, deps);
                  } else if (path === 'pom.xml') {
                    const ids = [...text.matchAll(/<artifactId>([^<]+)</g)].map(m => m[1]);
                    add(tech, ids);
                  } else if (path === 'build.gradle' || path === 'build.gradle.kts') {
                    const m = text.match(/(implementation|api|kapt)\([^\)]+\)/g) || [];
                    const libs = m.map(s => {
                      const g = s.match(/["']([^"']+):([^"':]+)["']/);
                      return g ? g[2] : null;
                    }).filter(Boolean);
                    add(tech, libs);
                  } else if (path === 'Cargo.toml') {
                    const seg = text.split('[dependencies]')[1] || '';
                    const deps = seg.split(/\r?\n/).map(l => l.split('=')[0].trim()).filter(Boolean);
                    add(tech, deps);
                  } else if (path === 'composer.json') {
                    try {
                      const j = JSON.parse(text);
                      add(tech, Object.keys(j.require || {}));
                      add(tech, Object.keys(j['require-dev'] || {}));
                    } catch {}
                  } else if (path === 'go.mod') {
                    const lines = [];
                    let inBlock = false;
                    for (const line of text.split(/\r?\n/)) {
                      if (line.startsWith('require (')) { inBlock = true; continue; }
                      if (inBlock && line.trim() === ')') { inBlock = false; continue; }
                      if (line.startsWith('require ') && !inBlock) {
                        const mod = line.split(/\s+/)[1];
                        if (mod) lines.push(mod);
                      } else if (inBlock) {
                        const mod = line.trim().split(/\s+/)[0];
                        if (mod) lines.push(mod);
                      }
                    }
                    const names = lines.map(m => m.split('/').pop());
                    add(tech, names);
                  }
                } catch (e) {
                  // ignore 404 for missing files
                  if (e.status !== 404) core.info(`Skip ${OWNER}/${r.name}:${path} (${e.status || ''})`);
                }
              }
            }

            // 2) Write AUTOSTACK.md
            const items = Array.from(tech).sort();
            let md = '# Detected frameworks, libs & tools\n\n';
            md += items.map(x => `- ${x}`).join('\n');
            md += '\n';
            fs.writeFileSync('AUTOSTACK.md', md, 'utf8');

            // 3) Inject between markers in README
            const readmePath = READ_ME;
            const readme = fs.readFileSync(readmePath, 'utf8');
            const start = '<!--AUTOSTACK:START-->';
            const end = '<!--AUTOSTACK:END-->';

            const i1 = readme.indexOf(start);
            const i2 = readme.indexOf(end);
            if (i1 === -1 || i2 === -1) {
              core.setFailed('AUTOSTACK markers not found in README.md');
              return;
            }

            const before = readme.slice(0, i1 + start.length);
            const after  = readme.slice(i2);
            const updated = `${before}\n\n${md}\n${after}`;
            if (updated !== readme) {
              fs.writeFileSync(readmePath, updated, 'utf8');
              core.notice(`Injected ${items.length} tech entries into README.md`);
            } else {
              core.notice('No changes to README.md');
            }

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: auto-update detected tech stack"
          file_pattern: |
            README.md
            AUTOSTACK.md
            .github/workflows/update-tech.yml
