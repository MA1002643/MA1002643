name: Auto-detect tech stack

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * 1" # Mondays 08:00 UTC

permissions:
  contents: write

jobs:
  tech:
    runs-on: ubuntu-latest
    env:
      OWNER: MA1002643
      README_PATH: README.md

      # Cap to keep things reasonable (raise if you want)
      MAX_ICONS: "40"

      # Always include these (and show them first)
      SEED_ICONS: "nextjs,react,ts,js,tailwind,nodejs,express,mongodb,mysql,git,githubactions,vercel,dotnet,aws"

      # Also update the long bullet list? (must have AUTOSTACK markers)
      WRITE_AUTOSTACK: "false"

    steps:
      - uses: actions/checkout@v4

      - name: Build & inject icons (one <picture> per icon)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            const OWNER = process.env.OWNER || context.repo.owner;
            const README_PATH = process.env.README_PATH || 'README.md';
            const MAX_ICONS = parseInt(process.env.MAX_ICONS || '40', 10);
            const WRITE_AUTOSTACK = (process.env.WRITE_AUTOSTACK || 'false').toLowerCase() === 'true';
            const SEED_ICONS = (process.env.SEED_ICONS || '').split(',').map(s => s.trim()).filter(Boolean);

            // ---------- helpers ----------
            const norm = s => (s||'').toLowerCase()
              .replace(/^@?types\//,'').replace(/^@?nestjs\//,'nestjs')
              .replace(/^@?angular\//,'angular').replace(/^@?mui\//,'mui')
              .replace(/^@?apollo\//,'apollo').replace(/@.*$/,'')
              .replace(/[><=~^*].*$/,'').replace(/[^a-z0-9+._-]/g,'').trim();

            function toSlug(name){
              const k = norm(name);
              const pairs = [
                [['javascript','js'],'js'], [['typescript','ts'],'ts'],
                [['python','py'],'py'], ['java','java'], [['go','golang'],'go'],
                [['csharp','c#'],'cs'], [['cpp','c++'],'cpp'], ['c','c'],
                ['php','php'], ['ruby','ruby'], ['kotlin','kotlin'], ['swift','swift'],
                ['dart','dart'], ['rust','rust'],
                [['react','reactdom'],'react'], [['next','nextjs','next.js'],'nextjs'],
                [['vue','vuejs'],'vue'], [['nuxt','nuxtjs'],'nuxtjs'],
                ['svelte','svelte'], ['angular','angular'], [['tailwind','tailwindcss'],'tailwind'],
                ['vite','vite'], ['webpack','webpack'], ['babel','babel'], [['three','threejs'],'threejs'],
                [['node','nodejs','node.js'],'nodejs'], [['express','expressjs'],'express'],
                ['nestjs','nestjs'], ['deno','deno'], ['bun','bun'],
                [['mongodb','mongoose'],'mongodb'], [['mysql','mysql2'],'mysql'],
                [['postgres','postgresql','pg'],'postgres'], ['sqlite','sqlite'],
                ['mariadb','mariadb'], ['redis','redis'],
                ['prisma','prisma'], ['sequelize','sequelize'], ['typeorm','typeorm'],
                [['aws','awssdk','awscli'],'aws'], ['azure','azure'], [['gcp','googlecloud'],'gcp'],
                ['vercel','vercel'], ['docker','docker'], [['kubernetes','k8s'],'kubernetes'],
                ['terraform','terraform'], ['ansible','ansible'], ['nginx','nginx'],
                [['githubactions','ghactions','actions'],'githubactions'], ['git','git'],
                ['jest','jest'], ['cypress','cypress'], ['playwright','playwright'],
                ['postman','postman'], ['eslint','eslint'], ['prettier','prettier'], ['storybook','storybook'],
                [['mui','materialui'],'mui'], [['chakraui','chakra'],'chakraui'],
                ['reactnative','react'], ['flutter','flutter'], ['electron','electron'],
                [['dotnet','.net'],'dotnet'],
                ['graphql','graphql'], ['apollo','apollo'], ['firebase','firebase'], ['supabase','supabase'],
                ['linux','linux'], [['bash','shell'],'bash'], ['powershell','powershell'],
                ['npm','npm'], ['pnpm','pnpm'], ['yarn','yarn'],
              ];
              for (const [keys, val] of pairs){
                if (Array.isArray(keys) ? keys.includes(k) : k === keys) return val;
              }
              return null;
            }

            const preferred = [
              'nextjs','react','ts','js','tailwind','nodejs','express',
              'mongodb','postgres','mysql','prisma',
              'git','githubactions','docker','vercel',
              'dotnet','aws','azure','gcp',
              'redis','sqlite','mariadb',
              'jest','cypress','playwright','postman',
              'eslint','prettier','webpack','vite',
              'graphql','apollo','firebase','supabase',
              'kubernetes','terraform','nginx',
              'py','java','go','cs','cpp','php','ruby','rust','kotlin','swift','dart'
            ];

            async function listRepos(owner){
              const out=[]; for(let p=1;p<=5;p++){
                const {data}=await github.request('GET /users/{username}/repos',{
                  username: owner, per_page:100, page:p, type:'public', sort:'updated'
                });
                if(!data?.length) break; out.push(...data);
              }
              return out;
            }

            const detected = new Set();
            const readable = new Set();

            let repos=[];
            try { repos = await listRepos(OWNER); } catch(e) {
              core.warning('Repo list failed: ' + (e.message || e));
            }

            for (const r of repos){
              const repo = r.name;
              const ref  = r.default_branch || 'main';

              // Languages
              try{
                const langs = await github.request('GET /repos/{owner}/{repo}/languages',{ owner: OWNER, repo });
                Object.keys(langs.data||{}).forEach(k => { detected.add(k); readable.add(k); });
              }catch{}

              // Root manifests (fast)
              const paths=['package.json','requirements.txt','pyproject.toml','composer.json','go.mod','Cargo.toml'];
              for (const path of paths){
                try{
                  const {data}=await github.request('GET /repos/{owner}/{repo}/contents/{path}',{ owner: OWNER, repo, path, ref });
                  if(!data || data.type!=='file' || !data.content) continue;
                  const text = Buffer.from(data.content,'base64').toString('utf8');

                  if (path==='package.json'){
                    try{
                      const j=JSON.parse(text);
                      [...Object.keys(j.dependencies||{}), ...Object.keys(j.devDependencies||{})]
                        .forEach(x => { detected.add(x); readable.add(x); });
                    }catch{}
                  } else if (path==='requirements.txt'){
                    text.split(/\r?\n/).map(l=>l.replace(/#.*/,'').trim()).filter(Boolean)
                      .map(l=>l.split(/[=<>~! ]/)[0]).forEach(x => { detected.add(x); readable.add(x); });
                  } else if (path==='pyproject.toml'){
                    const seg=text.split('[tool.poetry.dependencies]')[1]||'';
                    for (const ln of seg.split(/\r?\n/)) {
                      if (/^\[.+\]/.test(ln)) break;
                      const k=(ln.split('=')[0]||'').trim(); if (k){ detected.add(k); readable.add(k); }
                    }
                  } else if (path==='composer.json'){
                    try{
                      const j=JSON.parse(text);
                      [...Object.keys(j.require||{}), ...Object.keys(j['require-dev']||{})]
                        .forEach(x => { detected.add(x); readable.add(x); });
                    }catch{}
                  } else if (path==='go.mod'){
                    const lines=[]; let inBlock=false;
                    for (const ln of text.split(/\r?\n/)){
                      if (ln.startsWith('require (')){ inBlock=true; continue; }
                      if (inBlock && ln.trim()===')'){ inBlock=false; continue; }
                      if (ln.startsWith('require ') && !inBlock) lines.push(ln.split(/\s+/)[1]);
                      else if (inBlock) lines.push(ln.trim().split(/\s+/)[0]);
                    }
                    lines.map(m=>(m||'').split('/').pop()).forEach(x => { detected.add(x); readable.add(x); });
                  } else if (path==='Cargo.toml'){
                    const seg2=text.split('[dependencies]')[1]||'';
                    seg2.split(/\r?\n/).map(l=>(l.split('=')[0]||'').trim()).filter(Boolean)
                      .forEach(x => { detected.add(x); readable.add(x); });
                  }
                }catch(e){
                  if (e.status !== 404) core.info(`Skip ${OWNER}/${repo}:${path} (${e.status||e.message})`);
                }
              }
            }

            // Merge seed + detected, de-duplicate, order, cap
            const seed = SEED_ICONS.map(toSlug).filter(Boolean);
            const detectedSlugs = [...detected].map(toSlug).filter(Boolean);
            const merged = new Set([...seed, ...detectedSlugs]);

            const ordered = [
              ...preferred.filter(s => merged.has(s)),
              ...[...merged].filter(s => !preferred.includes(s)).sort()
            ].slice(0, MAX_ICONS);

            // Build ONE row: one <picture> per icon (robust on GitHub)
            const parts = [];
            parts.push('<p align="center" style="white-space:nowrap;">');
            for (const slug of ordered){
              parts.push('  <picture style="display:inline-block;margin:0 6px 6px 0;">');
              parts.push(`    <source media="(prefers-color-scheme: dark)" srcset="https://skillicons.dev/icons?i=${slug}&theme=dark">`);
              parts.push(`    <img src="https://skillicons.dev/icons?i=${slug}" alt="${slug}" height="44">`);
              parts.push('  </picture>');
            }
            parts.push('</p>');
            const iconsHTML = parts.join('\n');

            // Optional plain list
            const listMd = '# Detected frameworks, libs & tools\\n\\n' +
              [...new Set([...detected, ...seed])].sort().map(x => '- ' + x).join('\\n') + '\\n';

            function inject(src, start, end, payload){
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n' + payload + '\n' + src.slice(i2);
            }

            let readme = fs.readFileSync(README_PATH,'utf8');
            let updated = inject(readme, '<!--TECH:START-->', '<!--TECH:END-->', iconsHTML);
            if (!updated) { core.setFailed('README missing TECH markers'); return; }

            if (WRITE_AUTOSTACK){
              const maybe = inject(updated, '<!--AUTOSTACK:START-->', '<!--AUTOSTACK:END-->', listMd);
              if (maybe) updated = maybe;
            }

            if (updated !== readme){
              fs.writeFileSync(README_PATH, updated, 'utf8');
              core.notice(`Injected ${ordered.length} icons as individual <picture> elements`);
            } else {
              core.notice('No README changes');
            }

      - name: Remove stray literal \n lines in TECH block
        run: |
          # delete any line that is exactly "\n" inside README
          sed -i.bak '/^[[:space:]]*\\n[[:space:]]*$/d' README.md || true
          rm -f README.md.bak

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: auto-update tech icons (robust row)"
          file_pattern: README.md
