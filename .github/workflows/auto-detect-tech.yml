name: Auto-detect tech stack

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * 1" # Mondays 08:00 UTC

permissions:
  contents: write

jobs:
  tech:
    runs-on: ubuntu-latest
    env:
      OWNER: MA1002643
      README_PATH: README.md

      # Show many icons on one visual row by splitting into small chunks
      CHUNK_SIZE: "11" # 22 icons -> 2 chunks of 11
      MAX_ICONS: "40" # overall cap

      # These appear first and are always included
      SEED_ICONS: "nextjs,react,ts,js,tailwind,nodejs,express,mongodb,mysql,git,githubactions,vercel,dotnet,aws"

      # Also write the long bullet list under AUTOSTACK markers?
      WRITE_AUTOSTACK: "false"

    steps:
      - uses: actions/checkout@v4

      - name: Build & inject icons (GitHub-safe)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // NOTE: 'core', 'github', 'context' are provided by github-script.
            const fs = require('fs');

            const OWNER = process.env.OWNER || context.repo.owner;
            const README_PATH = process.env.README_PATH || 'README.md';
            const CHUNK_SIZE = parseInt(process.env.CHUNK_SIZE || '11', 10);
            const MAX_ICONS = parseInt(process.env.MAX_ICONS || '40', 10);
            const WRITE_AUTOSTACK = (process.env.WRITE_AUTOSTACK || 'false').toLowerCase() === 'true';
            const SEED_ICONS = (process.env.SEED_ICONS || '').split(',').map(s => s.trim()).filter(Boolean);

            const norm = s => (s||'').toLowerCase()
              .replace(/^@?types\//,'').replace(/^@?nestjs\//,'nestjs')
              .replace(/^@?angular\//,'angular').replace(/^@?mui\//,'mui')
              .replace(/^@?apollo\//,'apollo').replace(/@.*$/,'')
              .replace(/[><=~^*].*$/,'').replace(/[^a-z0-9+._-]/g,'').trim();

            function toSlug(name){
              const k = norm(name);
              const pairs = [
                // languages
                [['javascript','js'],'js'], [['typescript','ts'],'ts'], [['python','py'],'py'],
                [['java'],'java'], [['go','golang'],'go'], [['csharp','c#'],'cs'], [['cpp','c++'],'cpp'],
                [['c'],'c'], [['php'],'php'], [['ruby'],'ruby'], [['kotlin'],'kotlin'],
                [['swift'],'swift'], [['dart'],'dart'], [['rust'],'rust'],
                // frontend
                [['react','reactdom'],'react'], [['next','nextjs','next.js'],'nextjs'],
                [['vue','vuejs'],'vue'], [['nuxt','nuxtjs'],'nuxtjs'], [['svelte'],'svelte'],
                [['angular'],'angular'], [['tailwind','tailwindcss'],'tailwind'],
                [['vite'],'vite'], [['webpack'],'webpack'], [['babel'],'babel'], [['three','threejs'],'threejs'],
                // backend/runtime
                [['node','nodejs','node.js'],'nodejs'], [['express','expressjs'],'express'], [['nestjs'],'nestjs'],
                [['deno'],'deno'], [['bun'],'bun'],
                // db
                [['mongodb','mongoose'],'mongodb'], [['mysql','mysql2'],'mysql'],
                [['postgres','postgresql','pg'],'postgres'], [['sqlite'],'sqlite'], [['mariadb'],'mariadb'],
                [['redis'],'redis'],
                // orm
                [['prisma'],'prisma'], [['sequelize'],'sequelize'], [['typeorm'],'typeorm'],
                // cloud/devops
                [['aws','awssdk','awscli'],'aws'], [['azure'],'azure'], [['gcp','googlecloud'],'gcp'],
                [['vercel'],'vercel'], [['docker'],'docker'], [['kubernetes','k8s'],'kubernetes'],
                [['terraform'],'terraform'], [['ansible'],'ansible'], [['nginx'],'nginx'],
                [['githubactions','ghactions','actions'],'githubactions'], [['git'],'git'],
                // testing/tools
                [['jest'],'jest'], [['cypress'],'cypress'], [['playwright'],'playwright'],
                [['postman'],'postman'], [['eslint'],'eslint'], [['prettier'],'prettier'],
                [['storybook'],'storybook'],
                // ui libs
                [['mui','materialui'],'mui'], [['chakraui','chakra'],'chakraui'],
                // mobile/desktop
                [['reactnative'],'react'], [['flutter'],'flutter'], [['electron'],'electron'],
                // .net
                [['dotnet','.net'],'dotnet'],
                // misc
                [['graphql'],'graphql'], [['apollo'],'apollo'], [['firebase'],'firebase'],
                [['supabase'],'supabase'], [['linux'],'linux'], [['bash','shell'],'bash'],
                [['powershell'],'powershell'], [['npm'],'npm'], [['pnpm'],'pnpm'], [['yarn'],'yarn'],
              ];
              for (const [keys,val] of pairs) if (keys.includes(k)) return val;
              return null;
            }

            const preferred = [
              'nextjs','react','ts','js','tailwind','nodejs','express',
              'mongodb','postgres','mysql','prisma',
              'git','githubactions','docker','vercel',
              'dotnet','aws','azure','gcp',
              'redis','sqlite','mariadb',
              'jest','cypress','playwright','postman',
              'eslint','prettier','webpack','vite',
              'graphql','apollo','firebase','supabase',
              'kubernetes','terraform','nginx',
              'py','java','go','cs','cpp','php','ruby','rust','kotlin','swift','dart'
            ];

            async function listRepos(owner){
              const repos=[]; for(let p=1;p<=5;p++){
                const {data}=await github.request('GET /users/{username}/repos',{
                  username: owner, per_page:100, page:p, type:'public', sort:'updated'
                });
                if(!data?.length) break; repos.push(...data);
              } return repos;
            }

            const detected = new Set();
            const readable = new Set();

            let repos=[];
            try{ repos = await listRepos(OWNER); }catch(e){ core.warning('List failed: '+(e.message||e)); }

            for(const r of repos){
              const repo=r.name, ref=r.default_branch || 'main';

              // languages
              try{
                const langs = await github.request('GET /repos/{owner}/{repo}/languages',{ owner: OWNER, repo });
                Object.keys(langs.data||{}).forEach(k=>{ detected.add(k); readable.add(k); });
              }catch{}

              // common root manifests
              const paths=['package.json','requirements.txt','pyproject.toml','composer.json','go.mod','Cargo.toml'];
              for(const path of paths){
                try{
                  const {data}=await github.request('GET /repos/{owner}/{repo}/contents/{path}',{ owner: OWNER, repo, path, ref });
                  if(!data || data.type!=='file' || !data.content) continue;
                  const text = Buffer.from(data.content,'base64').toString('utf8');

                  if(path==='package.json'){
                    try{
                      const j=JSON.parse(text);
                      [...Object.keys(j.dependencies||{}), ...Object.keys(j.devDependencies||{})]
                        .forEach(x=>{ detected.add(x); readable.add(x); });
                    }catch{}
                  }else if(path==='requirements.txt'){
                    text.split(/\r?\n/).map(l=>l.replace(/#.*/,'').trim()).filter(Boolean)
                      .map(l=>l.split(/[=<>~! ]/)[0]).forEach(x=>{ detected.add(x); readable.add(x); });
                  }else if(path==='pyproject.toml'){
                    const seg=text.split('[tool.poetry.dependencies]')[1]||'';
                    for(const ln of seg.split(/\r?\n/)){
                      if(/^\[.+\]/.test(ln)) break;
                      const k=(ln.split('=')[0]||'').trim(); if(k){ detected.add(k); readable.add(k); }
                    }
                  }else if(path==='composer.json'){
                    try{
                      const j=JSON.parse(text);
                      [...Object.keys(j.require||{}), ...Object.keys(j['require-dev']||{})]
                        .forEach(x=>{ detected.add(x); readable.add(x); });
                    }catch{}
                  }else if(path==='go.mod'){
                    const lines=[]; let inBlock=false;
                    for(const ln of text.split(/\r?\n/)){
                      if(ln.startsWith('require (')){ inBlock=true; continue; }
                      if(inBlock && ln.trim()===')'){ inBlock=false; continue; }
                      if(ln.startsWith('require ') && !inBlock) lines.push(ln.split(/\s+/)[1]);
                      else if(inBlock) lines.push(ln.trim().split(/\s+/)[0]);
                    }
                    lines.map(m=>(m||'').split('/').pop()).forEach(x=>{ detected.add(x); readable.add(x); });
                  }else if(path==='Cargo.toml'){
                    const seg2=text.split('[dependencies]')[1]||'';
                    seg2.split(/\r?\n/).map(l=>(l.split('=')[0]||'').trim()).filter(Boolean)
                      .forEach(x=>{ detected.add(x); readable.add(x); });
                  }
                }catch(e){ if(e.status!==404) core.info(`Skip ${OWNER}/${repo}:${path} (${e.status||e.message})`); }
              }
            }

            // merge seeds + detections
            const seed = SEED_ICONS.map(toSlug).filter(Boolean);
            const detectedSlugs = [...detected].map(toSlug).filter(Boolean);
            const merged = new Set([...seed, ...detectedSlugs]);

            const ordered = [
              ...preferred.filter(s => merged.has(s)),
              ...[...merged].filter(s => !preferred.includes(s)).sort()
            ].slice(0, MAX_ICONS);

            // chunk for reliable rendering on GitHub
            const chunk = (arr,n)=>{const out=[]; for(let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n)); return out;};
            const chunks = chunk(ordered, CHUNK_SIZE);

            // Build GitHub-safe HTML (two <img> per chunk with #gh-*-mode-only)
            const parts = chunks.map(slugs => {
              const list = slugs.join(',');
              const light = `https://skillicons.dev/icons?i=${list}&perline=${slugs.length}#gh-light-mode-only`;
              const dark  = `https://skillicons.dev/icons?i=${list}&perline=${slugs.length}&theme=dark#gh-dark-mode-only`;
              return [
                '<span style="display:inline-block;margin:0 4px;line-height:0;">',
                `  <img src="${light}" alt="tech icons">`,
                `  <img src="${dark}"  alt="tech icons">`,
                '</span>'
              ].join('\n');
            });

            const iconsHTML = '<p align="center">\n' + parts.join('\n') + '\n</p>';

            // inject helpers
            function inject(src, start, end, payload){
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n' + payload + '\n' + src.slice(i2);
            }

            let readme = fs.readFileSync(README_PATH,'utf8');
            let updated = inject(readme, '<!--TECH:START-->', '<!--TECH:END-->', iconsHTML);
            if(!updated){ core.setFailed('README missing TECH markers'); return; }

            if (WRITE_AUTOSTACK){
              const listMd = '# Detected frameworks, libs & tools\\n\\n' +
                [...new Set([...readable])].sort().map(x=>'- '+x).join('\\n') + '\\n';
              updated = inject(updated, '<!--AUTOSTACK:START-->', '<!--AUTOSTACK:END-->', listMd) || updated;
            }

            if (updated !== readme){
              fs.writeFileSync(README_PATH, updated, 'utf8');
              core.notice(`Updated README with ${ordered.length} icons in ${chunks.length} chunk(s)`);
            } else {
              core.notice('No README changes');
            }

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: auto-update tech icons (chunked, GH-safe)"
          file_pattern: README.md
