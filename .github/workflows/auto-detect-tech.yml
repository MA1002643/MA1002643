name: Auto-detect tech stack

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * 1" # Mondays 08:00 UTC

permissions:
  contents: write

jobs:
  tech:
    runs-on: ubuntu-latest
    env:
      OWNER: MA1002643
      README_PATH: README.md

      # cap just in case (bump if you want more)
      MAX_ICONS: "40"

      # These appear first and are always included
      SEED_ICONS: "nextjs,react,ts,js,tailwind,nodejs,express,mongodb,mysql,git,githubactions,vercel,dotnet,aws"

      # Also update the long bullet list between AUTOSTACK markers?
      WRITE_AUTOSTACK: "false"

    steps:
      - uses: actions/checkout@v4

      - name: Build & inject icons (single picture, no duplicates)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            const OWNER = process.env.OWNER || context.repo.owner;
            const README_PATH = process.env.README_PATH || 'README.md';
            const MAX_ICONS = parseInt(process.env.MAX_ICONS || '40', 10);
            const WRITE_AUTOSTACK = (process.env.WRITE_AUTOSTACK || 'false').toLowerCase() === 'true';
            const SEED_ICONS = (process.env.SEED_ICONS || '').split(',').map(s => s.trim()).filter(Boolean);

            const norm = s => (s||'').toLowerCase()
              .replace(/^@?types\//,'').replace(/^@?nestjs\//,'nestjs')
              .replace(/^@?angular\//,'angular').replace(/^@?mui\//,'mui')
              .replace(/^@?apollo\//,'apollo').replace(/@.*$/,'')
              .replace(/[><=~^*].*$/,'').replace(/[^a-z0-9+._-]/g,'').trim();

            function toSlug(name){
              const k = norm(name);
              const map = new Map([
                // languages
                [['javascript','js'].toString(),'js'], [['typescript','ts'].toString(),'ts'],
                [['python','py'].toString(),'py'], ['java','java'], [['go','golang'].toString(),'go'],
                [['csharp','c#'].toString(),'cs'], [['cpp','c++'].toString(),'cpp'], ['c','c'],
                ['php','php'], ['ruby','ruby'], ['kotlin','kotlin'], ['swift','swift'],
                ['dart','dart'], ['rust','rust'],
                // frontend
                [['react','reactdom'].toString(),'react'], [['next','nextjs','next.js'].toString(),'nextjs'],
                [['vue','vuejs'].toString(),'vue'], [['nuxt','nuxtjs'].toString(),'nuxtjs'],
                ['svelte','svelte'], ['angular','angular'], [['tailwind','tailwindcss'].toString(),'tailwind'],
                ['vite','vite'], ['webpack','webpack'], ['babel','babel'], [['three','threejs'].toString(),'threejs'],
                // backend/runtime
                [['node','nodejs','node.js'].toString(),'nodejs'], [['express','expressjs'].toString(),'express'],
                ['nestjs','nestjs'], ['deno','deno'], ['bun','bun'],
                // db
                [['mongodb','mongoose'].toString(),'mongodb'], [['mysql','mysql2'].toString(),'mysql'],
                [['postgres','postgresql','pg'].toString(),'postgres'], ['sqlite','sqlite'],
                ['mariadb','mariadb'], ['redis','redis'],
                // orm
                ['prisma','prisma'], ['sequelize','sequelize'], ['typeorm','typeorm'],
                // cloud/devops
                [['aws','awssdk','awscli'].toString(),'aws'], ['azure','azure'], [['gcp','googlecloud'].toString(),'gcp'],
                ['vercel','vercel'], ['docker','docker'], [['kubernetes','k8s'].toString(),'kubernetes'],
                ['terraform','terraform'], ['ansible','ansible'], ['nginx','nginx'],
                [['githubactions','ghactions','actions'].toString(),'githubactions'], ['git','git'],
                // testing/tools
                ['jest','jest'], ['cypress','cypress'], ['playwright','playwright'],
                ['postman','postman'], ['eslint','eslint'], ['prettier','prettier'], ['storybook','storybook'],
                // ui
                [['mui','materialui'].toString(),'mui'], [['chakraui','chakra'].toString(),'chakraui'],
                // mobile/desktop
                ['reactnative','react'], ['flutter','flutter'], ['electron','electron'],
                // .net
                [['dotnet','.net'].toString(),'dotnet'],
                // misc
                ['graphql','graphql'], ['apollo','apollo'], ['firebase','firebase'], ['supabase','supabase'],
                ['linux','linux'], [['bash','shell'].toString(),'bash'], ['powershell','powershell'],
                ['npm','npm'], ['pnpm','pnpm'], ['yarn','yarn'],
              ]);
              for (const [keys, val] of map.entries()){
                const arr = keys.split(',');
                if (arr.includes(k)) return val;
                if (k === keys) return val;
              }
              return null;
            }

            const preferred = [
              'nextjs','react','ts','js','tailwind','nodejs','express',
              'mongodb','postgres','mysql','prisma',
              'git','githubactions','docker','vercel',
              'dotnet','aws','azure','gcp',
              'redis','sqlite','mariadb',
              'jest','cypress','playwright','postman',
              'eslint','prettier','webpack','vite',
              'graphql','apollo','firebase','supabase',
              'kubernetes','terraform','nginx',
              'py','java','go','cs','cpp','php','ruby','rust','kotlin','swift','dart'
            ];

            async function listRepos(owner){
              const out=[]; for(let p=1;p<=5;p++){
                const {data}=await github.request('GET /users/{username}/repos',{
                  username: owner, per_page:100, page:p, type:'public', sort:'updated'
                });
                if(!data?.length) break; out.push(...data);
              } return out;
            }

            const detected = new Set();
            const readable = new Set();

            let repos=[];
            try { repos = await listRepos(OWNER); } catch(e) {
              core.warning('Repo list failed: ' + (e.message || e));
            }

            for (const r of repos){
              const repo = r.name;
              const ref  = r.default_branch || 'main';

              // languages
              try{
                const langs = await github.request('GET /repos/{owner}/{repo}/languages',{ owner: OWNER, repo });
                Object.keys(langs.data||{}).forEach(k => { detected.add(k); readable.add(k); });
              }catch{}

              // manifests (root only)
              const paths=['package.json','requirements.txt','pyproject.toml','composer.json','go.mod','Cargo.toml'];
              for (const path of paths){
                try{
                  const {data}=await github.request('GET /repos/{owner}/{repo}/contents/{path}',{ owner: OWNER, repo, path, ref });
                  if(!data || data.type!=='file' || !data.content) continue;
                  const text = Buffer.from(data.content,'base64').toString('utf8');

                  if (path==='package.json'){
                    try{
                      const j=JSON.parse(text);
                      [...Object.keys(j.dependencies||{}), ...Object.keys(j.devDependencies||{})]
                        .forEach(x => { detected.add(x); readable.add(x); });
                    }catch{}
                  } else if (path==='requirements.txt'){
                    text.split(/\r?\n/).map(l=>l.replace(/#.*/,'').trim()).filter(Boolean)
                      .map(l=>l.split(/[=<>~! ]/)[0]).forEach(x => { detected.add(x); readable.add(x); });
                  } else if (path==='pyproject.toml'){
                    const seg=text.split('[tool.poetry.dependencies]')[1]||'';
                    for (const ln of seg.split(/\r?\n/)) {
                      if (/^\[.+\]/.test(ln)) break;
                      const k=(ln.split('=')[0]||'').trim(); if (k){ detected.add(k); readable.add(k); }
                    }
                  } else if (path==='composer.json'){
                    try{
                      const j=JSON.parse(text);
                      [...Object.keys(j.require||{}), ...Object.keys(j['require-dev']||{})]
                        .forEach(x => { detected.add(x); readable.add(x); });
                    }catch{}
                  } else if (path==='go.mod'){
                    const lines=[]; let inBlock=false;
                    for (const ln of text.split(/\r?\n/)){
                      if (ln.startsWith('require (')){ inBlock=true; continue; }
                      if (inBlock && ln.trim()===')'){ inBlock=false; continue; }
                      if (ln.startsWith('require ') && !inBlock) lines.push(ln.split(/\s+/)[1]);
                      else if (inBlock) lines.push(ln.trim().split(/\s+/)[0]);
                    }
                    lines.map(m=>(m||'').split('/').pop()).forEach(x => { detected.add(x); readable.add(x); });
                  } else if (path==='Cargo.toml'){
                    const seg2=text.split('[dependencies]')[1]||'';
                    seg2.split(/\r?\n/).map(l=>(l.split('=')[0]||'').trim()).filter(Boolean)
                      .forEach(x => { detected.add(x); readable.add(x); });
                  }
                }catch(e){
                  if (e.status !== 404) core.info(`Skip ${OWNER}/${repo}:${path} (${e.status||e.message})`);
                }
              }
            }

            // merge + order + cap
            const seed = SEED_ICONS.map(toSlug).filter(Boolean);
            const detectedSlugs = [...detected].map(toSlug).filter(Boolean);
            const merged = new Set([...seed, ...detectedSlugs]);

            const ordered = [
              ...preferred.filter(s => merged.has(s)),
              ...[...merged].filter(s => !preferred.includes(s)).sort()
            ].slice(0, MAX_ICONS);

            // ONE <picture> only (no duplicates)
            const list = ordered.join(',');
            const lightURL = `https://skillicons.dev/icons?i=${list}&perline=${ordered.length}`;
            const darkURL  = `https://skillicons.dev/icons?i=${list}&perline=${ordered.length}&theme=dark`;

            const iconsHTML = [
              '<p align="center">',
              '  <picture>',
              `    <source media="(prefers-color-scheme: dark)" srcset="${darkURL}">`,
              `    <img src="${lightURL}" alt="Detected tech stack icons">`,
              '  </picture>',
              '</p>'
            ].join('\n');

            function inject(src, start, end, payload){
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n' + payload + '\n' + src.slice(i2);
            }

            let readme = fs.readFileSync(README_PATH,'utf8');
            let updated = inject(readme, '<!--TECH:START-->', '<!--TECH:END-->', iconsHTML);
            if (!updated) { core.setFailed('README missing TECH markers'); return; }

            if (WRITE_AUTOSTACK){
              const listMd = '# Detected frameworks, libs & tools\\n\\n' +
                [...new Set([...detected, ...seed])].sort().map(x => '- ' + x).join('\\n') + '\\n';
              updated = inject(updated, '<!--AUTOSTACK:START-->', '<!--AUTOSTACK:END-->', listMd) || updated;
            }

            if (updated !== readme){
              fs.writeFileSync(README_PATH, updated, 'utf8');
              core.notice(`Injected ${ordered.length} icons (single picture)`);
            } else {
              core.notice('No README changes');
            }

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: auto-update tech icons (single block)"
          file_pattern: README.md
