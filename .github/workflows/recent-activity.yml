name: Update recent activity

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # daily 08:00 UTC

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build recent-activity block (STRICT, overwrite, MA1002643 only)
        uses: actions/github-script@v7
        with:
          # Prefer a PAT with read:org, repo, read:user, gist
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN || github.token }}
          script: |
            const fs = require("fs");
            const path = require("path");

            // ------------------------------------------------------------
            // CONFIG
            // ------------------------------------------------------------
            const USER = "MA1002643";              // GitHub username (owner)
            const OWNER_PREFIX = USER + "/";       // only repos owned by this user
            const DAYS = 30;                       // look back N days
            const MAX_LINES = 30;                  // max items to write to README
            const README = "README.md";            // profile README
            const ACT_START = "<!--RECENT_ACTIVITY:start-->";
            const ACT_END   = "<!--RECENT_ACTIVITY:end-->";
            const TS_START  = "<!--RECENT_ACTIVITY:last_update-->";
            const TS_END    = "<!--RECENT_ACTIVITY:last_update_end-->";
            const CACHE_DIR = ".github";
            const CACHE_FILE = path.join(CACHE_DIR, "activity-cache.json");

            // ------------------------------------------------------------
            // helpers
            // ------------------------------------------------------------
            function log(...args) {
              core.info(args.join(" "));
            }

            // date helpers
            const now = new Date();
            const nowISO = now.toISOString();
            const cutoff = new Date(Date.now() - DAYS * 24 * 60 * 60 * 1000);

            // London time (Europe/London) â€” GitHub runners have Node with Intl
            const londonFmt = new Intl.DateTimeFormat("en-GB", {
              timeZone: "Europe/London",
              dateStyle: "full",
              timeStyle: "medium",
            });
            const londonTimestamp = londonFmt.format(now);

            // ensure cache dir
            if (!fs.existsSync(CACHE_DIR)) {
              fs.mkdirSync(CACHE_DIR, { recursive: true });
            }

            // read old cache
            let cache = {};
            try {
              if (fs.existsSync(CACHE_FILE)) {
                cache = JSON.parse(fs.readFileSync(CACHE_FILE, "utf8"));
              }
            } catch (err) {
              core.warning("Could not read cache: " + err.message);
              cache = {};
            }

            // ------------------------------------------------------------
            // 1) COLLECT ACTIVITIES
            // Weâ€™ll combine:
            //  - GraphQL: recent contributions (PRs, issues, reviews, commits)
            //  - REST: user events (push, create, fork, etc.)
            // Then filter to repos owned by USER
            // ------------------------------------------------------------

            // GRAPHQL query for contributions
            const gql = `
              query($login: String!, $from: DateTime!) {
                user(login: $login) {
                  login
                  contributionsCollection(from: $from) {
                    pullRequestContributions(last: 50) {
                      nodes {
                        occurredAt
                        pullRequest {
                          title
                          url
                          number
                          repository {
                            nameWithOwner
                          }
                          merged
                        }
                      }
                    }
                    issueContributions(last: 50) {
                      nodes {
                        occurredAt
                        issue {
                          title
                          url
                          number
                          repository {
                            nameWithOwner
                          }
                        }
                      }
                    }
                    pullRequestReviewContributions(last: 50) {
                      nodes {
                        occurredAt
                        pullRequest {
                          title
                          url
                          number
                          repository {
                            nameWithOwner
                          }
                        }
                      }
                    }
                    commitContributionsByRepository(maxRepositories: 30) {
                      repository {
                        nameWithOwner
                      }
                      contributions(first: 30) {
                        nodes {
                          occurredAt
                          commitCount
                        }
                      }
                    }
                  }
                }
              }
            `;

            // run GraphQL
            const fromISO = cutoff.toISOString();
            const gqlResp = await github.graphql(gql, { login: USER, from: fromISO });

            const activities = [];

            // pull requests
            for (const prNode of gqlResp.user.contributionsCollection.pullRequestContributions.nodes) {
              const dt = new Date(prNode.occurredAt);
              if (dt < cutoff) continue;
              const repo = prNode.pullRequest.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              activities.push({
                type: prNode.pullRequest.merged ? "pr_merged" : "pr_opened",
                date: dt.toISOString(),
                repo,
                title: prNode.pullRequest.title,
                number: prNode.pullRequest.number,
                url: prNode.pullRequest.url
              });
            }

            // issues
            for (const isNode of gqlResp.user.contributionsCollection.issueContributions.nodes) {
              const dt = new Date(isNode.occurredAt);
              if (dt < cutoff) continue;
              const repo = isNode.issue.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              activities.push({
                type: "issue",
                date: dt.toISOString(),
                repo,
                title: isNode.issue.title,
                number: isNode.issue.number,
                url: isNode.issue.url
              });
            }

            // reviews
            for (const rvNode of gqlResp.user.contributionsCollection.pullRequestReviewContributions.nodes) {
              const dt = new Date(rvNode.occurredAt);
              if (dt < cutoff) continue;
              const repo = rvNode.pullRequest.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              activities.push({
                type: "review",
                date: dt.toISOString(),
                repo,
                title: rvNode.pullRequest.title,
                number: rvNode.pullRequest.number,
                url: rvNode.pullRequest.url
              });
            }

            // commits (we only know counts per repo, so we phrase it generically)
            for (const cRepo of gqlResp.user.contributionsCollection.commitContributionsByRepository) {
              const repo = cRepo.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              for (const cNode of cRepo.contributions.nodes) {
                const dt = new Date(cNode.occurredAt);
                if (dt < cutoff) continue;
                activities.push({
                  type: "push",
                  date: dt.toISOString(),
                  repo,
                  title: `${cNode.commitCount} commit(s) pushed`,
                  number: null,
                  url: null
                });
              }
            }

            // REST: user events (for create repo, fork, star, etc.)
            // We will fetch a few pages to be safe
            async function fetchUserEvents(username, pages = 3) {
              const events = [];
              for (let page = 1; page <= pages; page++) {
                const { data } = await github.request("GET /users/{username}/events", {
                  username,
                  per_page: 100,
                  page
                });
                events.push(...data);
                if (data.length < 100) break;
              }
              return events;
            }

            const restEvents = await fetchUserEvents(USER, 3);

            for (const ev of restEvents) {
              const dt = new Date(ev.created_at);
              if (dt < cutoff) continue;

              // repo name from event
              const fullName = ev.repo?.name;
              if (!fullName || !fullName.startsWith(OWNER_PREFIX)) {
                // we only want repos owned by USER
                continue;
              }

              // map types
              switch (ev.type) {
                case "CreateEvent":
                  activities.push({
                    type: "repo_created",
                    date: dt.toISOString(),
                    repo: fullName,
                    title: `Created ${ev.payload.ref_type || "repository"}`,
                    number: null,
                    url: null
                  });
                  break;
                case "PushEvent":
                  activities.push({
                    type: "push",
                    date: dt.toISOString(),
                    repo: fullName,
                    title: `Pushed ${ev.payload.size} commit(s)`,
                    number: null,
                    url: null
                  });
                  break;
                case "PullRequestEvent":
                  activities.push({
                    type: ev.payload.action === "closed" && ev.payload.pull_request.merged ? "pr_merged" : "pr",
                    date: dt.toISOString(),
                    repo: fullName,
                    title: ev.payload.pull_request.title,
                    number: ev.payload.pull_request.number,
                    url: ev.payload.pull_request.html_url
                  });
                  break;
                case "IssuesEvent":
                  activities.push({
                    type: "issue",
                    date: dt.toISOString(),
                    repo: fullName,
                    title: ev.payload.issue.title,
                    number: ev.payload.issue.number,
                    url: ev.payload.issue.html_url
                  });
                  break;
                case "WatchEvent":
                  activities.push({
                    type: "star",
                    date: dt.toISOString(),
                    repo: fullName,
                    title: "Starred repository",
                    number: null,
                    url: null
                  });
                  break;
                case "ForkEvent":
                  activities.push({
                    type: "fork",
                    date: dt.toISOString(),
                    repo: fullName,
                    title: "Forked repository",
                    number: null,
                    url: null
                  });
                  break;
                default:
                  // ignore others
                  break;
              }
            }

            // ------------------------------------------------------------
            // 2) DEDUP + SORT
            // we dedup by: type + repo + number + date (down to minute)
            // ------------------------------------------------------------
            const seen = new Set();
            const filtered = [];

            for (const act of activities) {
              const key = [
                act.type,
                act.repo,
                act.number ?? "none",
                act.title ?? "none",
                act.date.slice(0, 16), // minute-level
              ].join("|");

              if (seen.has(key)) continue;
              seen.add(key);
              filtered.push(act);
            }

            filtered.sort((a, b) => new Date(b.date) - new Date(a.date));

            // trim
            const finalActivities = filtered.slice(0, MAX_LINES);

            // ------------------------------------------------------------
            // 3) FORMAT AS MARKDOWN LIST
            // ------------------------------------------------------------
            function emojiForType(t) {
              switch (t) {
                case "pr_merged": return "ðŸŽ‰";
                case "pr_opened":
                case "pr": return "ðŸ“";
                case "issue": return "ðŸ›";
                case "review": return "âœ…";
                case "push": return "ðŸ“¦";
                case "repo_created": return "ðŸ“";
                case "star": return "â­";
                case "fork": return "ðŸ´";
                default: return "ðŸ“Œ";
              }
            }

            function formatItem(act, idx) {
              const em = emojiForType(act.type);
              const dateShort = new Date(act.date).toISOString().slice(0, 10);
              const repo = act.repo;
              const title = act.title ? act.title.replace(/\r?\n/g, " ") : "(no title)";

              // if URL exists, make title clickable
              const titlePart = act.url ? `[${title}](${act.url})` : title;

              switch (act.type) {
                case "pr_merged":
                  return `${idx}. ${em} Merged PR to **${repo}** â€“ ${titlePart} (${dateShort})`;
                case "pr_opened":
                case "pr":
                  return `${idx}. ${em} Opened PR in **${repo}** â€“ ${titlePart} (${dateShort})`;
                case "issue":
                  return `${idx}. ${em} Worked on issue in **${repo}** â€“ ${titlePart} (${dateShort})`;
                case "review":
                  return `${idx}. ${em} Reviewed PR in **${repo}** â€“ ${titlePart} (${dateShort})`;
                case "push":
                  return `${idx}. ${em} Pushed to **${repo}** â€“ ${titlePart} (${dateShort})`;
                case "repo_created":
                  return `${idx}. ${em} Created repo **${repo}** (${dateShort})`;
                case "star":
                  return `${idx}. ${em} Starred **${repo}** (${dateShort})`;
                case "fork":
                  return `${idx}. ${em} Forked **${repo}** (${dateShort})`;
                default:
                  return `${idx}. ${em} Activity in **${repo}** â€“ ${titlePart} (${dateShort})`;
              }
            }

            const mdLines = finalActivities.map((act, i) => formatItem(act, i + 1));
            const activityBlock = mdLines.join("\n");

            // ------------------------------------------------------------
            // 4) UPDATE README
            // ------------------------------------------------------------
            if (!fs.existsSync(README)) {
              throw new Error(`README file "${README}" not found in repository root.`);
            }

            let readmeTxt = fs.readFileSync(README, "utf8");

            if (!readmeTxt.includes(ACT_START) || !readmeTxt.includes(ACT_END)) {
              throw new Error("README does not contain recent activity markers.");
            }

            // replace activity block strictly
            const before = readmeTxt.split(ACT_START)[0];
            const after = readmeTxt.split(ACT_END)[1];

            readmeTxt = [
              before,
              ACT_START,
              "\n",
              activityBlock,
              "\n",
              ACT_END,
              after
            ].join("");

            // update timestamp block
            if (readmeTxt.includes(TS_START) && readmeTxt.includes(TS_END)) {
              const b2 = readmeTxt.split(TS_START)[0];
              const a2 = readmeTxt.split(TS_END)[1];
              readmeTxt = [
                b2,
                TS_START,
                "\nLast Updated: ",
                londonTimestamp,
                "\n",
                TS_END,
                a2
              ].join("");
            }

            fs.writeFileSync(README, readmeTxt, "utf8");

            // ------------------------------------------------------------
            // 5) REFRESH CACHE (descriptions, topics)
            // we pull all repos for USER via REST and store
            // ------------------------------------------------------------
            async function fetchAllRepos(username) {
              const all = [];
              let page = 1;
              while (true) {
                const { data } = await github.request("GET /users/{username}/repos", {
                  username,
                  per_page: 100,
                  page,
                  sort: "pushed"
                });
                all.push(...data);
                if (data.length < 100) break;
                page++;
              }
              return all;
            }

            const myRepos = await fetchAllRepos(USER);
            const repoCache = {};
            for (const r of myRepos) {
              // fetch topics
              const { data: repoData } = await github.request("GET /repos/{owner}/{repo}", {
                owner: USER,
                repo: r.name,
                mediaType: {
                  previews: ["mercy"]
                }
              });
              repoCache[r.full_name] = {
                description: repoData.description || "",
                topics: repoData.topics || [],
                pushed_at: repoData.pushed_at
              };
            }

            fs.writeFileSync(CACHE_FILE, JSON.stringify(repoCache, null, 2), "utf8");

            core.info("README and cache updated.");

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: |
            README.md
            .github/activity-cache.json
