name: Update recent activity

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # daily 08:00 UTC

permissions:
  contents: write

concurrency:
  group: recent-activity
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: "Build recent-activity block and inject into README (Repo-only, strict format)"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // ---- settings ----
            const USER = 'MA1002643'; // change if needed
            const DAYS = 30;
            const MAX_LINES = 30;
            const READ_ME = 'README.md';

            const ACT_START = '<!--RECENT_ACTIVITY:start-->';
            const ACT_END   = '<!--RECENT_ACTIVITY:end-->';
            const TS_START  = '<!--RECENT_ACTIVITY:last_update-->';
            const TS_END    = '<!--RECENT_ACTIVITY:last_update_end-->';

            const CACHE_PATH = '.github/activity-cache.json';

            // ---- time window ----
            const now = new Date();
            const from = new Date(now.getTime() - DAYS*24*60*60*1000);
            const within = (d) => {
              const dt = new Date(d);
              return dt >= from && dt <= now;
            };

            // ---- tiny helpers ----
            const items = [];
            const addItem = (date, key, text) => {
              if (!date || !key || !text) return;
              items.push({ date, key, text });
            };

            // ===== GraphQL pagination helper =====
            async function pageQuery(query, vars, pickPage) {
              let after = null;
              const nodes = [];
              while (true) {
                const v = Object.assign({}, vars, { after });
                const res = await github.graphql(query, v);
                const { page, pageInfo } = pickPage(res);
                if (page && page.length) nodes.push(...page);
                if (!pageInfo?.hasNextPage) break;
                after = pageInfo.endCursor;
              }
              return nodes;
            }

            // ===== GraphQL: PR/Review/Issue contributions (your actions) =====
            async function getPRContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { number state mergedAt repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: fromISO, to: toISO },
                (res) => {
                  const conn = res.user.contributionsCollection.pullRequestContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getReviewContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestReviewContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { number repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: fromISO, to: toISO },
                (res) => {
                  const conn = res.user.contributionsCollection.pullRequestReviewContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getIssueContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      issueContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          issue { number state repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: fromISO, to: toISO },
                (res) => {
                  const conn = res.user.contributionsCollection.issueContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            // ===== GraphQL: Repos (for description/topics & created repos) =====
            async function getOwnerRepos(login) {
              const q = `
                query($login:String!, $after:String) {
                  user(login:$login) {
                    repositories(ownerAffiliations: OWNER, first: 100, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        nameWithOwner
                        name
                        owner { login }
                        url
                        isFork
                        isPrivate
                        createdAt
                        updatedAt
                        description
                        repositoryTopics(first: 100) {
                          nodes { topic { name } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login },
                (res) => {
                  const conn = res.user.repositories;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            // ===== REST: public events (to get PushEvent, stars, forks, etc.) =====
            async function getPublicEvents(username, maxPages = 3) {
              const SAFE_MAX_PAGES = 3;
              const limit = Math.min(maxPages || SAFE_MAX_PAGES, SAFE_MAX_PAGES);
              const out = [];
              for (let page = 1; page <= limit; page++) {
                try {
                  const { data } = await github.request('GET /users/{username}/events/public', {
                    username, per_page: 100, page
                  });
                  if (!data || !data.length) break;
                  out.push(...data);
                } catch (err) {
                  if (err?.status === 422) {
                    core.warning(`Public events pagination capped at page ${page}. Using events fetched so far.`);
                    break;
                  }
                  throw err;
                }
              }
              if (limit < (maxPages || SAFE_MAX_PAGES)) {
                core.notice('Using truncated public events due to GitHub pagination cap.');
              }
              return out;
            }

            // ===== Load cache (descriptions & topics) =====
            let cache = { repos: {} };
            try {
              if (fs.existsSync(CACHE_PATH)) {
                cache = JSON.parse(fs.readFileSync(CACHE_PATH, 'utf8'));
              }
            } catch (e) {
              core.warning('Could not read cache: ' + e.message);
              cache = { repos: {} };
            }

            // ===== Gather data =====
            const fromISO = from.toISOString();
            const toISO = now.toISOString();

            const [prNodes, reviewNodes, issueNodes, repos, events] = await Promise.all([
              getPRContribs(USER, fromISO, toISO),
              getReviewContribs(USER, fromISO, toISO),
              getIssueContribs(USER, fromISO, toISO),
              getOwnerRepos(USER),
              getPublicEvents(USER, 3),
            ]);

            // ---- PRs (strict: "<icon> <action> to owner/repo")
            for (const n of prNodes) {
              if (!within(n.occurredAt)) continue;
              const pr = n.pullRequest;
              const repo = pr?.repository?.nameWithOwner;
              if (!repo) continue;
              const merged = !!pr.mergedAt;
              const state = pr.state;
              let label;
              if (merged) label = 'ðŸŽ‰ Merged PR';
              else if (state === 'OPEN') label = 'ðŸ’ª Opened PR';
              else label = 'âŒ Closed PR';
              addItem(n.occurredAt, `pr:${repo}:${label}`, `${label} to ${repo}`);
            }

            // ---- Reviews
            for (const n of reviewNodes) {
              if (!within(n.occurredAt)) continue;
              const repo = n.pullRequest?.repository?.nameWithOwner;
              if (!repo) continue;
              addItem(n.occurredAt, `review:${repo}`, `ðŸ” Reviewed PR to ${repo}`);
            }

            // ---- Issues
            for (const n of issueNodes) {
              if (!within(n.occurredAt)) continue;
              const is = n.issue;
              const repo = is?.repository?.nameWithOwner;
              if (!repo) continue;
              const label = is.state === 'OPEN' ? 'ðŸ“ Opened issue' : (is.state === 'CLOSED' ? 'âœ”ï¸ Closed issue' : 'ðŸ”§ Updated issue');
              addItem(n.occurredAt, `issue:${repo}:${label}`, `${label} to ${repo}`);
            }

            // ---- REST events: REPO-ONLY summary, no commit counts, no links
            const pushLatest = new Map(); // repo -> latest timestamp
            for (const ev of events) {
              const when = ev.created_at;
              if (!within(when)) continue;
              const full = ev.repo?.name; // owner/repo (required for inclusion)
              if (!full) continue;

              switch (ev.type) {
                case 'PushEvent': {
                  const prev = pushLatest.get(full);
                  if (!prev || new Date(when) > new Date(prev)) pushLatest.set(full, when);
                  break;
                }
                case 'WatchEvent': {
                  addItem(when, `watch:${full}`, `â­ Starred to ${full}`);
                  break;
                }
                case 'ForkEvent': {
                  addItem(when, `fork:${full}`, `ðŸ”± Forked to ${full}`);
                  break;
                }
                case 'CreateEvent': {
                  const rt = ev.payload?.ref_type;
                  if (rt === 'repository') {
                    addItem(when, `create-repo:${full}`, `ðŸ“¦ Created repository to ${full}`);
                  } else if (rt) {
                    addItem(when, `create:${full}:${rt}`, `ðŸ“¦ Created ${rt} to ${full}`);
                  }
                  break;
                }
                case 'DeleteEvent': {
                  const rt = ev.payload?.ref_type;
                  if (rt) addItem(when, `delete:${full}:${rt}`, `ðŸ—‘ï¸ Deleted ${rt} to ${full}`);
                  break;
                }
                case 'PublicEvent': {
                  addItem(when, `public:${full}`, `ðŸŒ Made public to ${full}`);
                  break;
                }
                case 'MemberEvent': {
                  addItem(when, `member:${full}`, `ðŸ‘¥ Added member to ${full}`);
                  break;
                }
                case 'GollumEvent': {
                  addItem(when, `wiki:${full}`, `ðŸ“ Updated wiki to ${full}`);
                  break;
                }
                case 'CommitCommentEvent': {
                  addItem(when, `commitcomment:${full}`, `ðŸ—£ï¸ Commented on a commit to ${full}`);
                  break;
                }
                case 'IssueCommentEvent': {
                  addItem(when, `issuecomment:${full}`, `ðŸ’¬ Commented on issue to ${full}`);
                  break;
                }
                case 'ReleaseEvent': {
                  addItem(when, `release:${full}`, `ðŸ·ï¸ Released to ${full}`);
                  break;
                }
                default:
                  // Ignore events that are not clearly repo-targeted or add noise
                  break;
              }
            }
            // Emit push summaries as one line per repo, newest first
            for (const [repo, latest] of pushLatest.entries()) {
              addItem(latest, `push:${repo}`, `â¬†ï¸ Pushed to ${repo}`);
            }

            // ---- Created repos via GraphQL (covers private creations you own)
            for (const r of repos) {
              if (r?.createdAt && within(r.createdAt)) {
                const full = r.nameWithOwner;
                if (!full) continue;
                addItem(r.createdAt, `repo-create:${full}`, `ðŸ“¦ Created repository to ${full}${r.isFork ? ' (fork)' : ''}`);
              }
            }

            // ---- Description & topics changes (compare to cache) -> plain text, repo-only
            function arrEq(a, b) {
              const A = (a || []).slice().sort();
              const B = (b || []).slice().sort();
              if (A.length !== B.length) return false;
              for (let i=0;i<A.length;i++) if (A[i] !== B[i]) return false;
              return true;
            }

            const newCache = { repos: {} };

            for (const r of repos) {
              const full = r.nameWithOwner;
              const updatedAt = r.updatedAt;
              const description = r.description || '';
              const topics = (r.repositoryTopics?.nodes || []).map(n => n?.topic?.name).filter(Boolean);

              const prev = cache.repos[full] || { description: null, topics: null, updatedAt: null };

              if (within(updatedAt)) {
                if (prev.description !== null && prev.description !== description) {
                  addItem(updatedAt, `desc-update:${full}:${updatedAt}`, `ðŸ“ Updated description to ${full}`);
                }
                if (prev.topics !== null && !arrEq(prev.topics, topics)) {
                  addItem(updatedAt, `topics-update:${full}:${updatedAt}`, `ðŸ·ï¸ Updated topics to ${full}`);
                }
              }

              newCache.repos[full] = { description, topics, updatedAt };
            }

            // ---- de-duplicate by key (keep newest)
            const map = new Map();
            for (const it of items) {
              const existing = map.get(it.key);
              if (!existing || new Date(it.date) > new Date(existing.date)) map.set(it.key, it);
            }
            const unique = Array.from(map.values());

            // ---- sort & format (STRICT format: "<icon> <action> to owner/repo")
            unique.sort((a,b) => new Date(b.date) - new Date(a.date));
            const lines = unique.slice(0, MAX_LINES).map((i, index) => `${index + 1}. ${i.text}<br>`);

            // ---- timestamp (Europe/London)
            const ordinal = (n) => {
              const s = ['th','st','nd','rd'], v = n % 100;
              return n + (s[(v - 20) % 10] || s[v] || s[0]);
            };
            const parts = new Intl.DateTimeFormat('en-GB', {
              timeZone: 'Europe/London',
              weekday:'long', month:'long', day:'numeric', year:'numeric',
              hour:'numeric', minute:'2-digit', second:'2-digit', hour12:true
            }).formatToParts(new Date())
              .reduce((a,p) => { a[p.type] = p.value; return a; }, {});
            const dayNum = parseInt(parts.day, 10);
            const lastUpdated = 'Last Updated: '
              + parts.weekday + ', ' + parts.month + ' ' + ordinal(dayNum) + ', ' + parts.year + ', '
              + parts.hour + ':' + parts.minute + ':' + parts.second + ' ' + parts.dayPeriod;

            // ---- inject into README (overwrite the block fully) ----
            const inject = (src, start, end, payload) => {
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n\n' + payload + '\n' + src.slice(i2);
            };

            let md = fs.readFileSync(READ_ME, 'utf8');

            // strip any previous markdown link patterns within the block to avoid old format
            const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const blockRe = new RegExp(
              esc(ACT_START) + '[\\s\\S]*?' + esc(ACT_END),
              'm'
            );
            md = md.replace(blockRe, (m) => m
              // [text](github link) -> text (belt-and-braces cleanup)
              .replace(/\[([^\]]+)\]\((?:https?:\/\/)?github\.com\/[^\)]+\)/g, '$1')
              // remove any residual "(X commits)" or "commit(s)" phrases
              .replace(/\b\d+\s+commit\(s\)\b/gi, '')
              .replace(/\bcommit\(s\)\b/gi, '')
              .replace(/\(\s*\)/g, '')
            );

            let updated = inject(md, ACT_START, ACT_END, lines.join('\n'));
            if (!updated) core.setFailed('Markers not found: RECENT_ACTIVITY:start/end');

            const tsBlockRE = new RegExp(esc(TS_START) + '[\\s\\S]*?' + esc(TS_END), 'm');
            if (tsBlockRE.test(updated)) {
              updated = updated.replace(tsBlockRE, TS_START + '\n\n' + lastUpdated + '\n\n' + TS_END);
            } else {
              core.warning('Timestamp markers not found; skipping last-updated line.');
            }

            // ---- write outputs ----
            if (updated !== md) {
              fs.writeFileSync(READ_ME, updated, 'utf8');
              core.notice('README updated with recent activity (strict repo-only format).');
            } else {
              core.notice('No README changes were necessary (format already correct).');
            }

            // persist cache
            fs.mkdirSync(path.dirname(CACHE_PATH), { recursive: true });
            fs.writeFileSync(CACHE_PATH, JSON.stringify(newCache, null, 2), 'utf8');

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: |
            README.md
            .github/activity-cache.json
