name: Update recent activity

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # daily 08:00 UTC

permissions:
  contents: write

concurrency:
  group: recent-activity
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: "Build recent-activity block and inject into README (Hybrid: GraphQL + REST + Cache)"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // ---- settings ----
            const USER = 'MA1002643'; // change if needed
            const DAYS = 30;
            const MAX_LINES = 30;
            const READ_ME = 'README.md';

            const ACT_START = '<!--RECENT_ACTIVITY:start-->';
            const ACT_END   = '<!--RECENT_ACTIVITY:end-->';
            const TS_START  = '<!--RECENT_ACTIVITY:last_update-->';
            const TS_END    = '<!--RECENT_ACTIVITY:last_update_end-->';

            const CACHE_PATH = '.github/activity-cache.json';

            // ---- time window ----
            const now = new Date();
            const from = new Date(now.getTime() - DAYS*24*60*60*1000);
            const within = (d) => {
              const dt = new Date(d);
              return dt >= from && dt <= now;
            };

            // ---- tiny helpers ----
            const items = [];
            const addItem = (date, key, text) => {
              if (!date || !key || !text) return;
              items.push({ date, key, text });
            };

            // ===== GraphQL pagination helper =====
            async function pageQuery(query, vars, pickPage) {
              let after = null;
              const nodes = [];
              while (true) {
                const v = Object.assign({}, vars, { after });
                const res = await github.graphql(query, v);
                const { page, pageInfo } = pickPage(res);
                if (page && page.length) nodes.push(...page);
                if (!pageInfo?.hasNextPage) break;
                after = pageInfo.endCursor;
              }
              return nodes;
            }

            // ===== GraphQL: PR/Review/Issue contributions (your actions) =====
            async function getPRContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { number state mergedAt repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: fromISO, to: toISO },
                (res) => {
                  const conn = res.user.contributionsCollection.pullRequestContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getReviewContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestReviewContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { number repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: fromISO, to: toISO },
                (res) => {
                  const conn = res.user.contributionsCollection.pullRequestReviewContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getIssueContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      issueContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          issue { number state repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: fromISO, to: toISO },
                (res) => {
                  const conn = res.user.contributionsCollection.issueContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            // ===== GraphQL: Repos (for description/topics & created repos) =====
            async function getOwnerRepos(login) {
              const q = `
                query($login:String!, $after:String) {
                  user(login:$login) {
                    repositories(ownerAffiliations: OWNER, first: 100, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        nameWithOwner
                        name
                        owner { login }
                        url
                        isFork
                        isPrivate
                        createdAt
                        updatedAt
                        description
                        repositoryTopics(first: 100) {
                          nodes { topic { name } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login },
                (res) => {
                  const conn = res.user.repositories;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            // ===== REST: public events (to get PushEvent commit counts, stars, forks, etc.) =====
            async function getPublicEvents(username, maxPages = 10) {
              const out = [];
              for (let page = 1; page <= maxPages; page++) {
                const { data } = await github.request('GET /users/{username}/events/public', {
                  username, per_page: 100, page
                });
                if (!data || !data.length) break;
                out.push(...data);
              }
              return out;
            }

            // ===== Load cache (descriptions & topics) =====
            let cache = { repos: {} };
            try {
              if (fs.existsSync(CACHE_PATH)) {
                cache = JSON.parse(fs.readFileSync(CACHE_PATH, 'utf8'));
              }
            } catch (e) {
              core.warning('Could not read cache: ' + e.message);
              cache = { repos: {} };
            }

            // ===== Gather data =====
            const fromISO = from.toISOString();
            const toISO = now.toISOString();

            const [prNodes, reviewNodes, issueNodes, repos, events] = await Promise.all([
              getPRContribs(USER, fromISO, toISO),
              getReviewContribs(USER, fromISO, toISO),
              getIssueContribs(USER, fromISO, toISO),
              getOwnerRepos(USER),
              getPublicEvents(USER, 10),
            ]);

            // ---- PRs (plain style)
            for (const n of prNodes) {
              if (!within(n.occurredAt)) continue;
              const pr = n.pullRequest;
              if (!pr) continue;
              const repo = pr.repository?.nameWithOwner;
              const num = pr.number;
              const merged = !!pr.mergedAt;
              const state = pr.state;
              let label;
              if (merged) label = '🎉 Merged PR';
              else if (state === 'OPEN') label = '💪 Opened PR';
              else label = '❌ Closed PR';
              if (repo && num != null) {
                addItem(n.occurredAt, `pr:${repo}#${num}:${label}`, `${label} #${num} in ${repo}`);
              }
            }

            // ---- Reviews
            for (const n of reviewNodes) {
              if (!within(n.occurredAt)) continue;
              const repo = n.pullRequest?.repository?.nameWithOwner;
              const num = n.pullRequest?.number;
              if (repo && num != null) {
                addItem(n.occurredAt, `review:${repo}#${num}`, `🔍 Reviewed PR #${num} in ${repo}`);
              }
            }

            // ---- Issues
            for (const n of issueNodes) {
              if (!within(n.occurredAt)) continue;
              const is = n.issue;
              if (!is) continue;
              const repo = is.repository?.nameWithOwner;
              const num = is.number;
              const label = is.state === 'OPEN' ? '📝 Opened issue' : (is.state === 'CLOSED' ? '✔️ Closed issue' : '🔧 Updated issue');
              if (repo && num != null) {
                addItem(n.occurredAt, `issue:${repo}#${num}:${label}`, `${label} #${num} in ${repo}`);
              }
            }

            // ---- REST events: Push (commit totals), stars, forks, releases, etc.
            // Accumulate commits by repo using PushEvent payload.size
            const pushAgg = new Map(); // repo -> {count, latest}
            for (const ev of events) {
              const when = ev.created_at;
              if (!within(when)) continue;
              const full = ev.repo?.name;

              switch (ev.type) {
                case 'PushEvent': {
                  const sz = (ev.payload && typeof ev.payload.size === 'number') ? ev.payload.size : 0;
                  if (!full || sz <= 0) break;
                  const cur = pushAgg.get(full) || { count: 0, latest: when };
                  cur.count += sz;
                  if (new Date(when) > new Date(cur.latest)) cur.latest = when;
                  pushAgg.set(full, cur);
                  break;
                }
                case 'WatchEvent': {
                  if (full) addItem(when, `watch:${full}:${when}`, `⭐ Starred ${full}`);
                  break;
                }
                case 'ForkEvent': {
                  const dst = ev.payload?.forkee?.full_name;
                  const left = `🔱 Forked ${full || 'a repository'}`;
                  const right = dst ? ` → ${dst}` : '';
                  addItem(when, `fork:${full}:${dst || when}`, left + right);
                  break;
                }
                case 'CreateEvent': {
                  const rt = ev.payload?.ref_type;
                  const ref = ev.payload?.ref;
                  if (rt === 'repository' && full) {
                    addItem(when, `create-repo:${full}`, `📦 Created repository ${full}`);
                  } else if (rt && ref && full) {
                    addItem(when, `create:${full}:${rt}:${ref}`, `📦 Created ${rt} \`${ref}\` in ${full}`);
                  }
                  break;
                }
                case 'DeleteEvent': {
                  const rt = ev.payload?.ref_type;
                  const ref = ev.payload?.ref;
                  if (full && rt && ref) addItem(when, `delete:${full}:${rt}:${ref}`, `🗑️ Deleted ${rt} \`${ref}\` in ${full}`);
                  break;
                }
                case 'PublicEvent': {
                  if (full) addItem(when, `public:${full}`, `🌐 Made ${full} public`);
                  break;
                }
                case 'MemberEvent': {
                  const m = ev.payload?.member?.login;
                  if (full) addItem(when, `member:${full}:${m || when}`, `👥 Added ${m ? '@'+m+' ' : ''}to ${full}`);
                  break;
                }
                case 'GollumEvent': {
                  if (full) addItem(when, `wiki:${full}:${when}`, `📝 Updated wiki in ${full}`);
                  break;
                }
                case 'CommitCommentEvent': {
                  if (full) addItem(when, `commitcomment:${full}:${when}`, `🗣️ Commented on a commit in ${full}`);
                  break;
                }
                case 'IssueCommentEvent': {
                  const n = ev.payload?.issue?.number;
                  if (full && n != null) addItem(when, `issuecomment:${full}#${n}:${when}`, `💬 Commented on issue #${n} in ${full}`);
                  break;
                }
                case 'GistEvent': {
                  const a = ev.payload?.action || 'updated';
                  const gistId = ev.payload?.gist?.id;
                  const label = a === 'create' ? 'Created' : 'Updated';
                  addItem(when, `gist:${a}:${gistId || when}`, `📄 ${label} a gist${gistId ? ' ('+gistId+')' : ''}`);
                  break;
                }
                case 'ReleaseEvent': {
                  const tag = ev.payload?.release?.tag_name;
                  if (full && tag) addItem(when, `release:${full}:${tag}:${when}`, `🏷️ Released \`${tag}\` in ${full}`);
                  break;
                }
                default:
                  break;
              }
            }
            // Emit commit totals
            for (const [repo, agg] of pushAgg.entries()) {
              addItem(agg.latest, `push:${repo}`, `⬆️ Pushed ${agg.count} commit(s) to ${repo}`);
            }

            // ---- Created repos via GraphQL (covers private creations you own)
            for (const r of repos) {
              if (r?.createdAt && within(r.createdAt)) {
                const full = r.nameWithOwner;
                const suffix = r.isFork ? ' (fork)' : '';
                addItem(r.createdAt, `repo-create:${full}`, `📦 Created repository ${full}${suffix}`);
              }
            }

            // ---- Description & topics changes (compare to cache)
            function arrEq(a, b) {
              const A = (a || []).slice().sort();
              const B = (b || []).slice().sort();
              if (A.length !== B.length) return false;
              for (let i=0;i<A.length;i++) if (A[i] !== B[i]) return false;
              return true;
            }

            const newCache = { repos: {} };

            for (const r of repos) {
              const full = r.nameWithOwner;
              const updatedAt = r.updatedAt;
              const description = r.description || '';
              const topics = (r.repositoryTopics?.nodes || []).map(n => n?.topic?.name).filter(Boolean);

              // previous snapshot
              const prev = cache.repos[full] || { description: null, topics: null, updatedAt: null };

              // Only announce if the repo update is within the window and a field changed
              if (within(updatedAt)) {
                if (prev.description !== null && prev.description !== description) {
                  addItem(updatedAt, `desc-update:${full}:${updatedAt}`, `📝 Updated description in ${full}`);
                }
                if (prev.topics !== null && !arrEq(prev.topics, topics)) {
                  addItem(updatedAt, `topics-update:${full}:${updatedAt}`, `🏷️ Updated topics in ${full}`);
                }
              }

              // Always refresh cache snapshot
              newCache.repos[full] = { description, topics, updatedAt };
            }

            // ---- de-duplicate by key (keep newest)
            const map = new Map();
            for (const it of items) {
              const existing = map.get(it.key);
              if (!existing || new Date(it.date) > new Date(existing.date)) map.set(it.key, it);
            }
            const unique = Array.from(map.values());

            // ---- sort & format
            unique.sort((a,b) => new Date(b.date) - new Date(a.date));
            const lines = unique.slice(0, MAX_LINES).map(i => `- ${i.text}`);

            // ---- timestamp (Europe/London)
            const ordinal = (n) => {
              const s = ['th','st','nd','rd'], v = n % 100;
              return n + (s[(v - 20) % 10] || s[v] || s[0]);
            };
            const parts = new Intl.DateTimeFormat('en-GB', {
              timeZone: 'Europe/London',
              weekday:'long', month:'long', day:'numeric', year:'numeric',
              hour:'numeric', minute:'2-digit', second:'2-digit', hour12:true
            }).formatToParts(new Date())
              .reduce((a,p) => { a[p.type] = p.value; return a; }, {});
            const dayNum = parseInt(parts.day, 10);
            const lastUpdated = 'Last Updated: '
              + parts.weekday + ', ' + parts.month + ' ' + ordinal(dayNum) + ', ' + parts.year + ', '
              + parts.hour + ':' + parts.minute + ':' + parts.second + ' ' + parts.dayPeriod;

            // ---- inject into README ----
            const inject = (src, start, end, payload) => {
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n\n' + payload + '\n' + src.slice(i2);
            };

            let md = fs.readFileSync(READ_ME, 'utf8');
            let updated = inject(md, ACT_START, ACT_END, lines.join('\n'));
            if (!updated) core.setFailed('Markers not found: RECENT_ACTIVITY:start/end');

            const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const blockRE = new RegExp(esc(TS_START) + '[\\s\\S]*?' + esc(TS_END), 'm');
            if (blockRE.test(updated)) {
              updated = updated.replace(blockRE, TS_START + '\n\n' + lastUpdated + '\n\n' + TS_END);
            } else {
              core.warning('Timestamp markers not found; skipping last-updated line.');
            }

            // ---- write outputs ----
            if (updated !== md) {
              fs.writeFileSync(READ_ME, updated, 'utf8');
              core.notice('README updated with recent activity.');
            } else {
              core.notice('No README changes were necessary.');
            }

            // persist cache
            fs.mkdirSync(path.dirname(CACHE_PATH), { recursive: true });
            fs.writeFileSync(CACHE_PATH, JSON.stringify(newCache, null, 2), 'utf8');

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: |
            README.md
            .github/activity-cache.json
