name: Update recent activity

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # every day at 08:00 UTC

permissions:
  contents: write

concurrency:
  group: recent-activity
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: "Build recent-activity block and inject into README (Hybrid: GraphQL + REST)"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN }}
          script: |
            const fs = require('fs');

            // ---- settings ----
            const USER = 'MA1002643'; // <-- change if needed
            const DAYS = 30;            // lookback window
            const MAX_LINES = 30;       // how many items to show
            const READ_ME = 'README.md';
            const ACT_START = '<!--RECENT_ACTIVITY:start-->';
            const ACT_END   = '<!--RECENT_ACTIVITY:end-->';
            const TS_START  = '<!--RECENT_ACTIVITY:last_update-->';
            const TS_END    = '<!--RECENT_ACTIVITY:last_update_end-->';

            // ---- time window ----
            const now = new Date();
            const from = new Date(now.getTime() - DAYS*24*60*60*1000);
            const within = (d) => {
              const dt = new Date(d);
              return dt >= from && dt <= now;
            };

            // ---- helpers ----
            const repoLink  = (full, url) => `[${full}](${url || ('https://github.com/' + full)})`;
            const prLink    = (full, n, url) => `[${full}#${n}](${url})`;
            const issueLink = (full, n, url) => `[${full}#${n}](${url})`;

            // Accumulator
            const items = [];

            // ============ GraphQL block (contributions + stars) ============
            const gql = `
              query($login:String!, $from:DateTime!, $to:DateTime!) {
                user(login:$login) {
                  contributionsCollection(from:$from, to:$to) {
                    commitContributionsByRepository(maxRepositories: 100) {
                      repository { nameWithOwner url }
                      contributions(first: 100) { nodes { occurredAt commitCount } }
                    }
                    pullRequestContributions(first: 200) {
                      nodes {
                        occurredAt
                        pullRequest { number url mergedAt state repository { nameWithOwner url } }
                      }
                    }
                    pullRequestReviewContributions(first: 200) {
                      nodes {
                        occurredAt
                        pullRequest { number url repository { nameWithOwner url } }
                      }
                    }
                    issueContributions(first: 200) {
                      nodes {
                        occurredAt
                        issue { number url state repository { nameWithOwner url } }
                      }
                    }
                    releaseContributions(first: 100) {
                      nodes {
                        occurredAt
                        release { tagName url repository { nameWithOwner url } }
                      }
                    }
                    repositoryContributions(first: 100, includeCreatedRepositories:true) {
                      nodes {
                        occurredAt
                        repository { nameWithOwner url isFork }
                      }
                    }
                  }
                  starredRepositories(first: 100, orderBy:{field: STARRED_AT, direction: DESC}) {
                    edges {
                      starredAt
                      node { nameWithOwner url }
                    }
                  }
                }
              }
            `;

            const vars = { login: USER, from: from.toISOString(), to: now.toISOString() };
            const res = await github.graphql(gql, vars);
            const cc = res.user.contributionsCollection;

            // Commits (sum per repo, latest occurrence)
            for (const r of (cc.commitContributionsByRepository || [])) {
              const full = r.repository && r.repository.nameWithOwner;
              const url  = r.repository && r.repository.url;
              let total = 0, latestAt = null;
              for (const n of (r.contributions && r.contributions.nodes) || []) {
                if (!within(n.occurredAt)) continue;
                total += (n.commitCount || 0);
                if (!latestAt || new Date(n.occurredAt) > new Date(latestAt)) latestAt = n.occurredAt;
              }
              if (full && total > 0) {
                items.push({ date: latestAt, key: 'commit:' + full, text: '‚¨ÜÔ∏è Pushed ' + total + ' commit(s) to ' + repoLink(full, url) });
              }
            }

            // PRs
            for (const n of (cc.pullRequestContributions && cc.pullRequestContributions.nodes) || []) {
              if (!within(n.occurredAt)) continue;
              const pr = n.pullRequest; if (!pr) continue;
              const full = pr.repository && pr.repository.nameWithOwner;
              const url  = pr.url;
              const num  = pr.number;
              const merged = !!pr.mergedAt;
              const state  = pr.state;
              const label  = merged ? 'üéâ Merged' : (state === 'OPEN' ? '‚ú® Opened' : '‚ùå Closed');
              if (full && url && num != null) {
                items.push({ date: n.occurredAt, key: 'pr:' + full + '#' + num + ':' + label, text: label + ' ' + prLink(full, num, url) });
              }
            }

            // Reviews
            for (const n of (cc.pullRequestReviewContributions && cc.pullRequestReviewContributions.nodes) || []) {
              if (!within(n.occurredAt)) continue;
              const pr = n.pullRequest; if (!pr) continue;
              const full = pr.repository && pr.repository.nameWithOwner;
              const url  = pr.url;
              const num  = pr.number;
              if (full && url && num != null) {
                items.push({ date: n.occurredAt, key: 'review:' + full + '#' + num, text: 'üîç Reviewed ' + prLink(full, num, url) });
              }
            }

            // Issues
            for (const n of (cc.issueContributions && cc.issueContributions.nodes) || []) {
              if (!within(n.occurredAt)) continue;
              const is = n.issue; if (!is) continue;
              const full = is.repository && is.repository.nameWithOwner;
              const url  = is.url;
              const num  = is.number;
              const label = is.state === 'OPEN' ? 'üìù Opened' : (is.state === 'CLOSED' ? '‚úîÔ∏è Closed' : 'üîß Updated');
              if (full && url && num != null) {
                items.push({ date: n.occurredAt, key: 'issue:' + full + '#' + num + ':' + label, text: label + ' ' + issueLink(full, num, url) });
              }
            }

            // Releases
            for (const n of (cc.releaseContributions && cc.releaseContributions.nodes) || []) {
              if (!within(n.occurredAt)) continue;
              const rel = n.release; if (!rel) continue;
              const repo = rel.repository && rel.repository.nameWithOwner;
              const tag  = rel.tagName;
              if (repo && tag) {
                items.push({ date: n.occurredAt, key: 'release:' + repo + ':' + tag, text: 'üè∑Ô∏è Released `' + tag + '` in ' + repoLink(repo) });
              }
            }

            // Repo creations (incl. forks)
            for (const n of (cc.repositoryContributions && cc.repositoryContributions.nodes) || []) {
              if (!within(n.occurredAt)) continue;
              const r = n.repository; if (!r) continue;
              const full = r.nameWithOwner;
              const url  = r.url;
              const suffix = r.isFork ? ' (fork)' : '';
              if (full && url) {
                items.push({ date: n.occurredAt, key: 'repo-create:' + full, text: 'üì¶ Created repository ' + repoLink(full, url) + suffix });
              }
            }

            // Stars (GraphQL ‚Äî has starredAt)
            for (const e of (res.user.starredRepositories && res.user.starredRepositories.edges) || []) {
              if (!e || !e.starredAt || !within(e.starredAt)) continue;
              const node = e.node || {};
              const full = node.nameWithOwner;
              const url  = node.url;
              if (full && url) {
                items.push({ date: e.starredAt, key: 'star:' + full + ':' + e.starredAt, text: '‚≠ê Starred ' + repoLink(full, url) });
              }
            }

            // ============ REST Events to capture ‚Äúeverything else‚Äù ============
            async function getEvents(username, pages) {
              const out = [];
              for (let page = 1; page <= pages; page++) {
                const { data } = await github.request('GET /users/{username}/events/public', {
                  username, per_page: 100, page
                });
                if (!data || !data.length) break;
                out.push(...data);
              }
              return out;
            }

            const events = await getEvents(USER, 10);

            // map REST events that aren‚Äôt guaranteed by GraphQL above
            for (const ev of events) {
              const t = ev.type;
              const when = ev.created_at;
              if (!within(when)) continue;

              const full = ev.repo && ev.repo.name;
              const add = (key, text) => items.push({ date: when, key, text });

              switch (t) {
                case 'ForkEvent': {
                  const dst = ev.payload && ev.payload.forkee && ev.payload.forkee.full_name;
                  const left = 'üî± Forked ' + (full ? repoLink(full) : 'a repository');
                  const right = dst ? (' ‚Üí [' + dst + '](https://github.com/' + dst + ')') : '';
                  add('fork:' + full + ':' + (dst || when), left + right);
                  break;
                }
                case 'WatchEvent': { // ‚ÄúStarred‚Äù in Events API
                  if (full) add('watch:' + full + ':' + when, '‚≠ê Starred ' + repoLink(full));
                  break;
                }
                case 'CreateEvent': {
                  const payload = ev.payload || {};
                  const ref_type = payload.ref_type;
                  const ref = payload.ref;
                  if (ref_type === 'repository') {
                    if (full) add('create-repo:' + full, 'üì¶ Created repository ' + repoLink(full));
                  } else if (ref_type && ref) {
                    if (full) add('create:' + full + ':' + ref_type + ':' + ref, 'üì¶ Created ' + ref_type + ' `' + ref + '` in ' + repoLink(full));
                  }
                  break;
                }
                case 'DeleteEvent': {
                  const payload = ev.payload || {};
                  const ref_type = payload.ref_type;
                  const ref = payload.ref;
                  if (full && ref_type && ref) add('delete:' + full + ':' + ref_type + ':' + ref, 'üóëÔ∏è Deleted ' + ref_type + ' `' + ref + '` in ' + repoLink(full));
                  break;
                }
                case 'PublicEvent': {
                  if (full) add('public:' + full, 'üåê Made ' + repoLink(full) + ' public');
                  break;
                }
                case 'MemberEvent': {
                  const m = ev.payload && ev.payload.member && ev.payload.member.login;
                  if (full) add('member:' + full + ':' + (m || when), 'üë• Added ' + (m ? ('@' + m + ' ') : '') + 'to ' + repoLink(full));
                  break;
                }
                case 'GollumEvent': {
                  if (full) add('wiki:' + full + ':' + when, 'üìù Updated wiki in ' + repoLink(full));
                  break;
                }
                case 'CommitCommentEvent': {
                  if (full) add('commitcomment:' + full + ':' + when, 'üó£Ô∏è Commented on a commit in ' + repoLink(full));
                  break;
                }
                case 'IssueCommentEvent': {
                  const n = ev.payload && ev.payload.issue && ev.payload.issue.number;
                  if (full && n != null) {
                    const url = 'https://github.com/' + full + '/issues/' + n;
                    add('issuecomment:' + full + '#' + n + ':' + when, 'üí¨ Commented on ' + issueLink(full, n, url));
                  }
                  break;
                }
                case 'FollowEvent': {
                  const tgt = ev.payload && ev.payload.target && ev.payload.target.login;
                  if (tgt) items.push({ date: when, key: 'follow:' + tgt + ':' + when, text: '‚ûï Followed @' + tgt });
                  break;
                }
                case 'GistEvent': {
                  const a = (ev.payload && ev.payload.action) || 'updated';
                  const gistId = ev.payload && ev.payload.gist && ev.payload.gist.id;
                  const label = a === 'create' ? 'Created' : 'Updated';
                  add('gist:' + a + ':' + (gistId || when), 'üìÑ ' + label + ' a gist' + (gistId ? (' (' + gistId + ')') : ''));
                  break;
                }
                case 'ReleaseEvent': {
                  const tag = ev.payload && ev.payload.release && ev.payload.release.tag_name;
                  if (full && tag) add('release:' + full + ':' + tag + ':' + when, 'üè∑Ô∏è Released `' + tag + '` in ' + repoLink(full));
                  break;
                }
                default:
                  // Skip Push/PR/Issues here to avoid dupes (handled by GraphQL)
                  break;
              }
            }

            // ---- dedupe by key, prefer newest ----
            const map = new Map();
            for (const it of items) {
              if (!it || !it.key || !it.date || !it.text) continue;
              const existing = map.get(it.key);
              if (!existing || new Date(it.date) > new Date(existing.date)) map.set(it.key, it);
            }
            const unique = Array.from(map.values());

            // ---- sort and limit ----
            unique.sort((a,b) => new Date(b.date) - new Date(a.date));
            const lines = unique.slice(0, MAX_LINES).map(i => i.text + '<br>');

            if (!lines.length) {
              core.notice('No recent activity in the selected window.');
            }

            // ---- timestamp (Europe/London with ordinal) ----
            const ordinal = (n) => {
              const s = ['th','st','nd','rd'], v = n % 100;
              return n + (s[(v - 20) % 10] || s[v] || s[0]);
            };
            const parts = new Intl.DateTimeFormat('en-GB', {
              timeZone: 'Europe/London',
              weekday:'long', month:'long', day:'numeric', year:'numeric',
              hour:'numeric', minute:'2-digit', second:'2-digit', hour12:true
            }).formatToParts(new Date())
              .reduce((a,p) => { a[p.type] = p.value; return a; }, {});
            const dayNum = parseInt(parts.day, 10);
            const lastUpdated = 'Last Updated: '
              + parts.weekday + ', ' + parts.month + ' ' + ordinal(dayNum) + ', ' + parts.year + ', '
              + parts.hour + ':' + parts.minute + ':' + parts.second + ' ' + parts.dayPeriod;

            // ---- inject into README ----
            const inject = (src, start, end, payload) => {
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n\n' + payload + '\n' + src.slice(i2);
            };

            let md = fs.readFileSync(READ_ME, 'utf8');
            let updated = inject(md, ACT_START, ACT_END, lines.join('\n'));
            if (!updated) core.setFailed('Markers not found: RECENT_ACTIVITY:start/end');

            const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const blockRE = new RegExp(esc(TS_START) + '[\\s\\S]*?' + esc(TS_END), 'm');
            if (blockRE.test(updated)) {
              updated = updated.replace(blockRE, TS_START + '\n\n' + lastUpdated + '\n\n' + TS_END);
            } else {
              core.warning('Timestamp markers not found; skipping last-updated line.');
            }

            if (updated !== md) {
              updated = updated.replace(/^\s*\\n\s*$/gm, '');
              fs.writeFileSync(READ_ME, updated, 'utf8');
              core.notice('README updated with hybrid recent activity.');
            } else {
              core.notice('No README changes were necessary.');
            }

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: README.md
