name: Update recent activity

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # daily 08:00 UTC

permissions:
  contents: write

concurrency:
  group: recent-activity
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: "Build recent-activity block (STRICT, overwrite, MA1002643 only)"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // ------------------------------------------------------------
            // CONFIG
            // ------------------------------------------------------------
            const USER = 'MA1002643';  // your username
            const DAYS = 30;
            const MAX_LINES = 30;
            const README = 'README.md';

            const ACT_START = '<!--RECENT_ACTIVITY:start-->';
            const ACT_END   = '<!--RECENT_ACTIVITY:end-->';
            const TS_START  = '<!--RECENT_ACTIVITY:last_update-->';
            const TS_END    = '<!--RECENT_ACTIVITY:last_update_end-->';

            const CACHE_PATH = '.github/activity-cache.json';

            // ------------------------------------------------------------
            // TIME
            // ------------------------------------------------------------
            const now = new Date();
            const from = new Date(now.getTime() - DAYS * 24 * 60 * 60 * 1000);
            const within = (iso) => {
              const d = new Date(iso);
              return d >= from && d <= now;
            };

            // ------------------------------------------------------------
            // HELPERS
            // ------------------------------------------------------------
            const items = [];
            const addItem = (date, key, text) => {
              if (!date || !key || !text) return;
              items.push({ date, key, text });
            };

            // we ONLY allow repos that start with "USER/"
            const allowRepo = (full) => {
              if (!full) return false;
              return full.startsWith(`${USER}/`);
            };

            async function pageQuery(query, vars, pickPage) {
              let after = null;
              const nodes = [];
              while (true) {
                const v = { ...vars, after };
                const res = await github.graphql(query, v);
                const { page, pageInfo } = pickPage(res);
                if (page && page.length) nodes.push(...page);
                if (!pageInfo?.hasNextPage) break;
                after = pageInfo.endCursor;
              }
              return nodes;
            }

            // ------------------------------------------------------------
            // GRAPHQL fetches
            // ------------------------------------------------------------
            async function getPRContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest {
                            mergedAt
                            state
                            repository { nameWithOwner }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(q, { login, from: fromISO, to: toISO }, (res) => {
                const conn = res.user.contributionsCollection.pullRequestContributions;
                return { page: conn.nodes, pageInfo: conn.pageInfo };
              });
            }

            async function getReviewContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestReviewContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { repository { nameWithOwner } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(q, { login, from: fromISO, to: toISO }, (res) => {
                const conn = res.user.contributionsCollection.pullRequestReviewContributions;
                return { page: conn.nodes, pageInfo: conn.pageInfo };
              });
            }

            async function getIssueContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      issueContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          issue {
                            state
                            repository { nameWithOwner }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(q, { login, from: fromISO, to: toISO }, (res) => {
                const conn = res.user.contributionsCollection.issueContributions;
                return { page: conn.nodes, pageInfo: conn.pageInfo };
              });
            }

            // we still want repos for description/topics cache, but we won't print those changes here
            async function getOwnerRepos(login) {
              const q = `
                query($login:String!, $after:String) {
                  user(login:$login) {
                    repositories(ownerAffiliations: OWNER, first: 100, orderBy: {field: UPDATED_AT, direction: DESC}, after: $after) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        nameWithOwner
                        createdAt
                        updatedAt
                        description
                        repositoryTopics(first: 100) { nodes { topic { name } } }
                        isFork
                      }
                    }
                  }
                }
              `;
              return pageQuery(q, { login }, (res) => {
                const conn = res.user.repositories;
                return { page: conn.nodes, pageInfo: conn.pageInfo };
              });
            }

            async function getPublicEvents(username, maxPages = 3) {
              const limit = Math.min(maxPages, 3);
              const out = [];
              for (let page = 1; page <= limit; page++) {
                const { data } = await github.request('GET /users/{username}/events/public', {
                  username,
                  per_page: 100,
                  page
                });
                if (!data || !data.length) break;
                out.push(...data);
              }
              return out;
            }

            // ------------------------------------------------------------
            // LOAD CACHE (for future use)
            // ------------------------------------------------------------
            let cache = { repos: {} };
            try {
              if (fs.existsSync(CACHE_PATH)) {
                cache = JSON.parse(fs.readFileSync(CACHE_PATH, 'utf8'));
              }
            } catch {
              cache = { repos: {} };
            }

            // ------------------------------------------------------------
            // FETCH
            // ------------------------------------------------------------
            const fromISO = from.toISOString();
            const toISO = now.toISOString();

            const [prNodes, reviewNodes, issueNodes, repos, events] = await Promise.all([
              getPRContribs(USER, fromISO, toISO),
              getReviewContribs(USER, fromISO, toISO),
              getIssueContribs(USER, fromISO, toISO),
              getOwnerRepos(USER),
              getPublicEvents(USER, 3),
            ]);

            // ------------------------------------------------------------
            // BUILD ITEMS
            // ------------------------------------------------------------

            // PRs
            for (const n of prNodes) {
              if (!within(n.occurredAt)) continue;
              const repo = n.pullRequest?.repository?.nameWithOwner;
              if (!allowRepo(repo)) continue;
              const merged = !!n.pullRequest.mergedAt;
              const state = n.pullRequest.state;
              let label;
              if (merged) label = 'ðŸŽ‰ Merged PR';
              else if (state === 'OPEN') label = 'ðŸ’ª Opened PR';
              else label = 'âŒ Closed PR';
              addItem(n.occurredAt, `pr:${repo}:${label}`, `${label} to ${repo}`);
            }

            // Reviews
            for (const n of reviewNodes) {
              if (!within(n.occurredAt)) continue;
              const repo = n.pullRequest?.repository?.nameWithOwner;
              if (!allowRepo(repo)) continue;
              addItem(n.occurredAt, `review:${repo}`, `ðŸ” Reviewed PR to ${repo}`);
            }

            // Issues
            for (const n of issueNodes) {
              if (!within(n.occurredAt)) continue;
              const issue = n.issue;
              const repo = issue?.repository?.nameWithOwner;
              if (!allowRepo(repo)) continue;
              const label = issue.state === 'OPEN'
                ? 'ðŸ“ Opened issue'
                : issue.state === 'CLOSED'
                  ? 'âœ”ï¸ Closed issue'
                  : 'ðŸ”§ Updated issue';
              addItem(n.occurredAt, `issue:${repo}:${label}`, `${label} to ${repo}`);
            }

            // REST events (STRICT)
            const pushLatest = new Map(); // repo -> latest date
            for (const ev of events) {
              const when = ev.created_at;
              if (!within(when)) continue;
              const repo = ev.repo?.name;
              if (!allowRepo(repo)) continue;

              switch (ev.type) {
                case 'PushEvent': {
                  // we ONLY record 1 line per repo (latest)
                  const prev = pushLatest.get(repo);
                  if (!prev || new Date(when) > new Date(prev)) {
                    pushLatest.set(repo, when);
                  }
                  break;
                }
                case 'WatchEvent': {
                  addItem(when, `star:${repo}`, `â­ Starred to ${repo}`);
                  break;
                }
                case 'ForkEvent': {
                  addItem(when, `fork:${repo}`, `ðŸ”± Forked to ${repo}`);
                  break;
                }
                case 'CreateEvent': {
                  const rt = ev.payload?.ref_type;
                  // we EXPLICITLY ignore branches/tags to avoid "Created branch"
                  if (rt === 'repository') {
                    addItem(when, `create-repo:${repo}`, `ðŸ“¦ Created repository to ${repo}`);
                  }
                  break;
                }
                case 'DeleteEvent': {
                  // ignore deletes to avoid "Deleted branch"
                  break;
                }
                default:
                  // skip noisy events
                  break;
              }
            }

            // add push lines
            for (const [repo, latest] of pushLatest.entries()) {
              addItem(latest, `push:${repo}`, `â¬†ï¸ Pushed to ${repo}`);
            }

            // ------------------------------------------------------------
            // DEDUP & SORT
            // ------------------------------------------------------------
            const map = new Map();
            for (const it of items) {
              const existing = map.get(it.key);
              if (!existing || new Date(it.date) > new Date(existing.date)) {
                map.set(it.key, it);
              }
            }
            const unique = Array.from(map.values());
            unique.sort((a, b) => new Date(b.date) - new Date(a.date));

            // ------------------------------------------------------------
            // FORMAT: EXACTLY "1. icon text to USER/repo"
            // ------------------------------------------------------------
            const lines = unique.slice(0, MAX_LINES).map((it, idx) => {
              let text = it.text;

              // hard clean in case anything leaked
              text = text
                .replace(/undefined commit\(s\)\s*to\s*/gi, 'to ')
                .replace(/\[([^\]]+)\]\((?:https?:\/\/)?github\.com\/[^\)]+\)/gi, '$1')
                .replace(/\(?\d+\s+commit\(s\)\)?/gi, '')
                .replace(/\s{2,}/g, ' ')
                .trim();

              return `${idx + 1}. ${text}`;
            });

            // ------------------------------------------------------------
            // TIMESTAMP (Europe/London)
            // ------------------------------------------------------------
            const ordinal = (n) => {
              const s = ['th','st','nd','rd'], v = n % 100;
              return n + (s[(v - 20) % 10] || s[v] || s[0]);
            };
            const parts = new Intl.DateTimeFormat('en-GB', {
              timeZone: 'Europe/London',
              weekday: 'long',
              month: 'long',
              day: 'numeric',
              year: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              second: '2-digit',
              hour12: true
            }).formatToParts(new Date())
              .reduce((a, p) => { a[p.type] = p.value; return a; }, {});
            const dayNum = parseInt(parts.day, 10);
            const lastUpdated = 'Last Updated: '
              + parts.weekday + ', '
              + parts.month + ' ' + ordinal(dayNum) + ', '
              + parts.year + ', '
              + parts.hour + ':' + parts.minute + ':' + parts.second + ' ' + parts.dayPeriod;

            // ------------------------------------------------------------
            // OVERWRITE README BLOCK (NO MERGE, NO REUSE)
            // ------------------------------------------------------------
            let md = fs.readFileSync(README, 'utf8');

            const startIdx = md.indexOf(ACT_START);
            const endIdx = md.indexOf(ACT_END);

            if (startIdx === -1 || endIdx === -1) {
              core.setFailed('Markers not found in README.md');
            }

            const before = md.slice(0, startIdx + ACT_START.length);
            const after = md.slice(endIdx);

            const newBlock = '\n\n' + lines.join('\n') + '\n';

            let updated = before + newBlock + after;

            // timestamp block
            const tsStartIdx = updated.indexOf(TS_START);
            const tsEndIdx = updated.indexOf(TS_END);
            if (tsStartIdx !== -1 && tsEndIdx !== -1) {
              const beforeTS = updated.slice(0, tsStartIdx + TS_START.length);
              const afterTS = updated.slice(tsEndIdx);
              updated = beforeTS + '\n\n' + lastUpdated + '\n\n' + afterTS;
            }

            if (updated !== md) {
              fs.writeFileSync(README, updated, 'utf8');
              core.notice('README updated (strict overwrite).');
            } else {
              core.notice('README already up to date.');
            }

            // ------------------------------------------------------------
            // SAVE CACHE (unchanged logic)
            // ------------------------------------------------------------
            const newCache = { repos: {} };
            for (const r of repos) {
              newCache.repos[r.nameWithOwner] = {
                description: r.description || '',
                topics: (r.repositoryTopics?.nodes || []).map(n => n?.topic?.name).filter(Boolean),
                updatedAt: r.updatedAt,
              };
            }
            fs.mkdirSync(path.dirname(CACHE_PATH), { recursive: true });
            fs.writeFileSync(CACHE_PATH, JSON.stringify(newCache, null, 2), 'utf8');

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: |
            README.md
            .github/activity-cache.json
