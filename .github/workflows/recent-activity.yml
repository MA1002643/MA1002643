name: Update recent activity

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # daily 08:00 UTC

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build recent-activity block (STRICT, overwrite, MA1002643 only)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN || github.token }}
          script: |
            const fs = require("fs");
            const path = require("path");

            // ------------------------------------------------------------
            // CONFIG
            // ------------------------------------------------------------
            const USER = "MA1002643";
            const OWNER_PREFIX = USER + "/";
            const DAYS = 30;
            const MAX_LINES = 12;              // <- you wanted 1..12
            const README = "README.md";

            const ACT_START = "<!--RECENT_ACTIVITY:start-->";
            const ACT_END   = "<!--RECENT_ACTIVITY:end-->";
            const TS_START  = "<!--RECENT_ACTIVITY:last_update-->";
            const TS_END    = "<!--RECENT_ACTIVITY:last_update_end-->";

            const CACHE_DIR = ".github";
            const CACHE_FILE = path.join(CACHE_DIR, "activity-cache.json");

            const now = new Date();
            const cutoff = new Date(Date.now() - DAYS * 24 * 60 * 60 * 1000);

            const londonFmt = new Intl.DateTimeFormat("en-GB", {
              timeZone: "Europe/London",
              dateStyle: "full",
              timeStyle: "medium",
            });
            const londonTimestamp = londonFmt.format(now);

            if (!fs.existsSync(CACHE_DIR)) {
              fs.mkdirSync(CACHE_DIR, { recursive: true });
            }

            let cache = {};
            try {
              if (fs.existsSync(CACHE_FILE)) {
                cache = JSON.parse(fs.readFileSync(CACHE_FILE, "utf8"));
              }
            } catch (err) {
              core.warning("Could not read cache: " + err.message);
              cache = {};
            }

            // ------------------------------------------------------------
            // 1) GRAPHQL CONTRIBUTIONS
            // ------------------------------------------------------------
            const gql = `
              query($login: String!, $from: DateTime!) {
                user(login: $login) {
                  contributionsCollection(from: $from) {
                    pullRequestContributions(last: 50) {
                      nodes {
                        occurredAt
                        pullRequest {
                          title
                          url
                          number
                          repository { nameWithOwner }
                          merged
                        }
                      }
                    }
                    issueContributions(last: 50) {
                      nodes {
                        occurredAt
                        issue {
                          title
                          url
                          number
                          repository { nameWithOwner }
                        }
                      }
                    }
                    pullRequestReviewContributions(last: 50) {
                      nodes {
                        occurredAt
                        pullRequest {
                          title
                          url
                          number
                          repository { nameWithOwner }
                        }
                      }
                    }
                    commitContributionsByRepository(maxRepositories: 30) {
                      repository { nameWithOwner }
                      contributions(first: 30) {
                        nodes {
                          occurredAt
                          commitCount
                        }
                      }
                    }
                  }
                }
              }
            `;

            const gqlResp = await github.graphql(gql, {
              login: USER,
              from: cutoff.toISOString()
            });

            const activities = [];

            // PRs
            for (const prNode of gqlResp.user.contributionsCollection.pullRequestContributions.nodes) {
              const dt = new Date(prNode.occurredAt);
              if (dt < cutoff) continue;
              const repo = prNode.pullRequest.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              activities.push({
                type: prNode.pullRequest.merged ? "pr_merged" : "pr_opened",
                date: dt.toISOString(),
                repo,
              });
            }

            // Issues
            for (const isNode of gqlResp.user.contributionsCollection.issueContributions.nodes) {
              const dt = new Date(isNode.occurredAt);
              if (dt < cutoff) continue;
              const repo = isNode.issue.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              activities.push({
                type: "issue",
                date: dt.toISOString(),
                repo,
              });
            }

            // Reviews
            for (const rvNode of gqlResp.user.contributionsCollection.pullRequestReviewContributions.nodes) {
              const dt = new Date(rvNode.occurredAt);
              if (dt < cutoff) continue;
              const repo = rvNode.pullRequest.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              activities.push({
                type: "review",
                date: dt.toISOString(),
                repo,
              });
            }

            // Commits (generic push)
            for (const cRepo of gqlResp.user.contributionsCollection.commitContributionsByRepository) {
              const repo = cRepo.repository?.nameWithOwner;
              if (!repo || !repo.startsWith(OWNER_PREFIX)) continue;
              for (const cNode of cRepo.contributions.nodes) {
                const dt = new Date(cNode.occurredAt);
                if (dt < cutoff) continue;
                activities.push({
                  type: "push",
                  date: dt.toISOString(),
                  repo,
                });
              }
            }

            // ------------------------------------------------------------
            // 2) REST EVENTS
            // ------------------------------------------------------------
            async function fetchUserEvents(username, pages = 3) {
              const events = [];
              for (let page = 1; page <= pages; page++) {
                const { data } = await github.request("GET /users/{username}/events", {
                  username,
                  per_page: 100,
                  page
                });
                events.push(...data);
                if (data.length < 100) break;
              }
              return events;
            }

            const restEvents = await fetchUserEvents(USER, 3);

            for (const ev of restEvents) {
              const dt = new Date(ev.created_at);
              if (dt < cutoff) continue;
              const fullName = ev.repo?.name;
              if (!fullName || !fullName.startsWith(OWNER_PREFIX)) continue;

              switch (ev.type) {
                case "CreateEvent":
                  activities.push({
                    type: "repo_created",
                    date: dt.toISOString(),
                    repo: fullName,
                  });
                  break;
                case "PushEvent": {
                  // make sure we never get undefined
                  activities.push({
                    type: "push",
                    date: dt.toISOString(),
                    repo: fullName,
                  });
                  break;
                }
                case "PullRequestEvent":
                  activities.push({
                    type: ev.payload.action === "closed" && ev.payload.pull_request.merged ? "pr_merged" : "pr",
                    date: dt.toISOString(),
                    repo: fullName,
                  });
                  break;
                case "IssuesEvent":
                  activities.push({
                    type: "issue",
                    date: dt.toISOString(),
                    repo: fullName,
                  });
                  break;
                case "WatchEvent":
                  activities.push({
                    type: "star",
                    date: dt.toISOString(),
                    repo: fullName,
                  });
                  break;
                case "ForkEvent":
                  activities.push({
                    type: "fork",
                    date: dt.toISOString(),
                    repo: fullName,
                  });
                  break;
                default:
                  break;
              }
            }

            // ------------------------------------------------------------
            // 3) DEDUP + SORT
            // ------------------------------------------------------------
            const seen = new Set();
            const filtered = [];

            for (const act of activities) {
              const key = [
                act.type,
                act.repo,
                act.date.slice(0, 16),
              ].join("|");
              if (seen.has(key)) continue;
              seen.add(key);
              filtered.push(act);
            }

            filtered.sort((a, b) => new Date(b.date) - new Date(a.date));
            const finalActivities = filtered.slice(0, MAX_LINES);

            // ------------------------------------------------------------
            // 4) FORMAT (NO LINKS, NO DETAILS)
            // ------------------------------------------------------------
            function emojiForType(t) {
              switch (t) {
                case "pr_merged": return "🎉";
                case "pr_opened":
                case "pr": return "📝";
                case "issue": return "🐛";
                case "review": return "✅";
                case "push": return "📦";
                case "repo_created": return "📁";
                case "star": return "⭐";
                case "fork": return "🍴";
                default: return "📌";
              }
            }

            function actionText(act) {
              switch (act.type) {
                case "pr_merged": return "Merged PR in";
                case "pr_opened":
                case "pr": return "Opened PR in";
                case "issue": return "Worked on issue in";
                case "review": return "Reviewed PR in";
                case "push": return "Pushed to";
                case "repo_created": return "Created";
                case "star": return "Starred";
                case "fork": return "Forked";
                default: return "Activity in";
              }
            }

            const mdLines = finalActivities.map((act, idx) => {
              const em = emojiForType(act.type);
              const actTxt = actionText(act);
              // <- NO LINK, ONLY TEXT + BRACKETS
              return `${idx + 1}. ${em} ${actTxt} [${act.repo}]`;
            });

            const activityBlock = mdLines.join("\n");

            // ------------------------------------------------------------
            // 5) UPDATE README
            // ------------------------------------------------------------
            if (!fs.existsSync(README)) {
              throw new Error(`README file "${README}" not found.`);
            }

            let readmeTxt = fs.readFileSync(README, "utf8");

            if (!readmeTxt.includes(ACT_START) || !readmeTxt.includes(ACT_END)) {
              throw new Error("README does not contain recent activity markers.");
            }

            const before = readmeTxt.split(ACT_START)[0];
            const after = readmeTxt.split(ACT_END)[1];

            readmeTxt = [
              before,
              ACT_START,
              "\n",
              activityBlock,
              "\n",
              ACT_END,
              after
            ].join("");

            // timestamp block
            if (readmeTxt.includes(TS_START) && readmeTxt.includes(TS_END)) {
              const b2 = readmeTxt.split(TS_START)[0];
              const a2 = readmeTxt.split(TS_END)[1];
              readmeTxt = [
                b2,
                TS_START,
                "\nLast Updated: ",
                londonTimestamp,
                "\n",
                TS_END,
                a2
              ].join("");
            }

            fs.writeFileSync(README, readmeTxt, "utf8");

            // ------------------------------------------------------------
            // 6) REFRESH CACHE (leave as-is)
            // ------------------------------------------------------------
            async function fetchAllRepos(username) {
              const all = [];
              let page = 1;
              while (true) {
                const { data } = await github.request("GET /users/{username}/repos", {
                  username,
                  per_page: 100,
                  page,
                  sort: "pushed"
                });
                all.push(...data);
                if (data.length < 100) break;
                page++;
              }
              return all;
            }

            const myRepos = await fetchAllRepos(USER);
            const repoCache = {};
            for (const r of myRepos) {
              const { data: repoData } = await github.request("GET /repos/{owner}/{repo}", {
                owner: USER,
                repo: r.name,
                mediaType: { previews: ["mercy"] }
              });
              repoCache[r.full_name] = {
                description: repoData.description || "",
                topics: repoData.topics || [],
                pushed_at: repoData.pushed_at
              };
            }

            fs.writeFileSync(CACHE_FILE, JSON.stringify(repoCache, null, 2), "utf8");

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: |
            README.md
            .github/activity-cache.json
