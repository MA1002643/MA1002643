name: Update recent activity (hybrid)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 8 * * *" # daily 08:00 UTC

permissions:
  contents: write

concurrency:
  group: recent-activity
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: "Build recent-activity block and inject into README (Hybrid: GraphQL + REST)"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ACTIVITY_GH_TOKEN || github.token }}
          script: |
            const fs = require('fs');

            // ---- settings ----
            const USER = 'MA1002643'; // change if needed
            const DAYS = 30;
            const MAX_LINES = 30;
            const READ_ME = 'README.md';
            const ACT_START = '<!--RECENT_ACTIVITY:start-->';
            const ACT_END   = '<!--RECENT_ACTIVITY:end-->';
            const TS_START  = '<!--RECENT_ACTIVITY:last_update-->';
            const TS_END    = '<!--RECENT_ACTIVITY:last_update_end-->';

            // ---- time window ----
            const now = new Date();
            const from = new Date(now.getTime() - DAYS*24*60*60*1000);
            const within = (d) => {
              const dt = new Date(d);
              return dt >= from && dt <= now;
            };

            // ---- helpers ----
            const repoLink  = (full, url) => `[${full}](${url || ('https://github.com/' + full)})`;
            const prLink    = (full, n, url) => `[${full}#${n}](${url})`;
            const issueLink = (full, n, url) => `[${full}#${n}](${url})`;
            const items = [];

            // ===== GraphQL pagination helpers =====
            async function pageQuery(query, vars, pickPage) {
              let after = null;
              const nodes = [];
              while (true) {
                const v = Object.assign({}, vars, { after });
                const res = await github.graphql(query, v);
                const { page, pageInfo } = pickPage(res);
                if (page && page.length) nodes.push(...page);
                if (!pageInfo?.hasNextPage) break;
                after = pageInfo.endCursor;
              }
              return nodes;
            }

            // Commits by repository (no pagination object for repos; limit to 100 repos)
            async function getCommits(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      commitContributionsByRepository(maxRepositories: 100) {
                        repository { nameWithOwner url }
                        contributions(first: 100) { nodes { occurredAt commitCount } }
                      }
                    }
                  }
                }
              `;
              const res = await github.graphql(q, { login, from: fromISO, to: toISO });
              return (res.user?.contributionsCollection?.commitContributionsByRepository) || [];
            }

            async function getPRContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { number url mergedAt state repository { nameWithOwner url } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: from.toISOString(), to: now.toISOString() },
                (res) => {
                  const conn = res.user.contributionsCollection.pullRequestContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getReviewContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      pullRequestReviewContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          pullRequest { number url repository { nameWithOwner url } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: from.toISOString(), to: now.toISOString() },
                (res) => {
                  const conn = res.user.contributionsCollection.pullRequestReviewContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getIssueContribs(login, fromISO, toISO) {
              const q = `
                query($login:String!, $from:DateTime!, $to:DateTime!, $after:String) {
                  user(login:$login) {
                    contributionsCollection(from:$from, to:$to) {
                      issueContributions(first: 100, after: $after) {
                        pageInfo { hasNextPage endCursor }
                        nodes {
                          occurredAt
                          issue { number url state repository { nameWithOwner url } }
                        }
                      }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login, from: from.toISOString(), to: now.toISOString() },
                (res) => {
                  const conn = res.user.contributionsCollection.issueContributions;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getStars(login) {
              const q = `
                query($login:String!, $after:String) {
                  user(login:$login) {
                    starredRepositories(first: 100, orderBy:{field: STARRED_AT, direction: DESC}, after: $after) {
                      pageInfo { hasNextPage endCursor }
                      edges { starredAt node { nameWithOwner url } }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login },
                (res) => {
                  const conn = res.user.starredRepositories;
                  return { page: conn.edges, pageInfo: conn.pageInfo };
                }
              );
            }

            async function getCreatedRepos(login) {
              const q = `
                query($login:String!, $after:String) {
                  user(login:$login) {
                    repositories(ownerAffiliations: OWNER, first: 100, orderBy: {field: CREATED_AT, direction: DESC}, after: $after) {
                      pageInfo { hasNextPage endCursor }
                      nodes { nameWithOwner url isFork createdAt }
                    }
                  }
                }
              `;
              return pageQuery(
                q,
                { login },
                (res) => {
                  const conn = res.user.repositories;
                  return { page: conn.nodes, pageInfo: conn.pageInfo };
                }
              );
            }

            // ===== Fetch via GraphQL =====
            const fromISO = from.toISOString();
            const toISO = now.toISOString();

            const commitRepos = await getCommits(USER, fromISO, toISO);
            const prNodes     = await getPRContribs(USER, fromISO, toISO);
            const reviewNodes = await getReviewContribs(USER, fromISO, toISO);
            const issueNodes  = await getIssueContribs(USER, fromISO, toISO);
            const starEdges   = await getStars(USER);
            const createdRepos= await getCreatedRepos(USER);

            // ---- Commits: sum per repo and take latest date
            for (const r of commitRepos) {
              const full = r.repository && r.repository.nameWithOwner;
              const url  = r.repository && r.repository.url;
              let total = 0, latestAt = null;
              for (const n of (r.contributions?.nodes || [])) {
                if (!within(n.occurredAt)) continue;
                total += (n.commitCount || 0);
                if (!latestAt || new Date(n.occurredAt) > new Date(latestAt)) latestAt = n.occurredAt;
              }
              if (full && total > 0) {
                items.push({ date: latestAt, key: 'commit:' + full, text: '‚¨ÜÔ∏è Pushed ' + total + ' commit(s) to ' + repoLink(full, url) });
              }
            }

            // ---- PRs
            for (const n of prNodes) {
              if (!within(n.occurredAt)) continue;
              const pr = n.pullRequest; if (!pr) continue;
              const full = pr.repository && pr.repository.nameWithOwner;
              const url  = pr.url;
              const num  = pr.number;
              const merged = !!pr.mergedAt;
              const state  = pr.state;
              const label  = merged ? 'üéâ Merged' : (state === 'OPEN' ? '‚ú® Opened' : '‚ùå Closed');
              if (full && url && num != null) {
                items.push({ date: n.occurredAt, key: 'pr:' + full + '#' + num + ':' + label, text: label + ' ' + prLink(full, num, url) });
              }
            }

            // ---- Reviews
            for (const n of reviewNodes) {
              if (!within(n.occurredAt)) continue;
              const pr = n.pullRequest; if (!pr) continue;
              const full = pr.repository && pr.repository.nameWithOwner;
              const url  = pr.url;
              const num  = pr.number;
              if (full && url && num != null) {
                items.push({ date: n.occurredAt, key: 'review:' + full + '#' + num, text: 'üîç Reviewed ' + prLink(full, num, url) });
              }
            }

            // ---- Issues
            for (const n of issueNodes) {
              if (!within(n.occurredAt)) continue;
              const is = n.issue; if (!is) continue;
              const full = is.repository && is.repository.nameWithOwner;
              const url  = is.url;
              const num  = is.number;
              const label = is.state === 'OPEN' ? 'üìù Opened' : (is.state === 'CLOSED' ? '‚úîÔ∏è Closed' : 'üîß Updated');
              if (full && url && num != null) {
                items.push({ date: n.occurredAt, key: 'issue:' + full + '#' + num + ':' + label, text: label + ' ' + issueLink(full, num, url) });
              }
            }

            // ---- Created repos (incl. forks) filtered by createdAt window
            for (const r of createdRepos) {
              if (!r?.createdAt || !within(r.createdAt)) continue;
              const full = r.nameWithOwner;
              const url  = r.url;
              const suffix = r.isFork ? ' (fork)' : '';
              items.push({ date: r.createdAt, key: 'repo-create:' + full, text: 'üì¶ Created repository ' + repoLink(full, url) + suffix });
            }

            // ---- Stars (GraphQL)
            for (const e of starEdges) {
              if (!e?.starredAt || !within(e.starredAt)) continue;
              const node = e.node || {};
              const full = node.nameWithOwner;
              const url  = node.url;
              if (full && url) {
                items.push({ date: e.starredAt, key: 'star:' + full + ':' + e.starredAt, text: '‚≠ê Starred ' + repoLink(full, url) });
              }
            }

            // ===== REST: public events for everything else =====
            async function getEvents(username, pages) {
              const out = [];
              for (let page = 1; page <= pages; page++) {
                const { data } = await github.request('GET /users/{username}/events/public', {
                  username, per_page: 100, page
                });
                if (!data || !data.length) break;
                out.push(...data);
              }
              return out;
            }

            const events = await getEvents(USER, 10);

            for (const ev of events) {
              const t = ev.type;
              const when = ev.created_at;
              if (!within(when)) continue;

              const full = ev.repo && ev.repo.name;
              const add = (key, text) => items.push({ date: when, key, text });

              switch (t) {
                case 'ForkEvent': {
                  const dst = ev.payload && ev.payload.forkee && ev.payload.forkee.full_name;
                  const left = 'üî± Forked ' + (full ? repoLink(full) : 'a repository');
                  const right = dst ? (' ‚Üí [' + dst + '](https://github.com/' + dst + ')') : '';
                  add('fork:' + full + ':' + (dst || when), left + right);
                  break;
                }
                case 'WatchEvent': {
                  if (full) add('watch:' + full + ':' + when, '‚≠ê Starred ' + repoLink(full));
                  break;
                }
                case 'CreateEvent': {
                  const payload = ev.payload || {};
                  const ref_type = payload.ref_type;
                  const ref = payload.ref;
                  if (ref_type === 'repository') {
                    if (full) add('create-repo:' + full, 'üì¶ Created repository ' + repoLink(full));
                  } else if (ref_type && ref) {
                    if (full) add('create:' + full + ':' + ref_type + ':' + ref, 'üì¶ Created ' + ref_type + ' `' + ref + '` in ' + repoLink(full));
                  }
                  break;
                }
                case 'DeleteEvent': {
                  const payload = ev.payload || {};
                  const ref_type = payload.ref_type;
                  const ref = payload.ref;
                  if (full && ref_type && ref) add('delete:' + full + ':' + ref_type + ':' + ref, 'üóëÔ∏è Deleted ' + ref_type + ' `' + ref + '` in ' + repoLink(full));
                  break;
                }
                case 'PublicEvent': {
                  if (full) add('public:' + full, 'üåê Made ' + repoLink(full) + ' public');
                  break;
                }
                case 'MemberEvent': {
                  const m = ev.payload && ev.payload.member && ev.payload.member.login;
                  if (full) add('member:' + full + ':' + (m || when), 'üë• Added ' + (m ? ('@' + m + ' ') : '') + 'to ' + repoLink(full));
                  break;
                }
                case 'GollumEvent': {
                  if (full) add('wiki:' + full + ':' + when, 'üìù Updated wiki in ' + repoLink(full));
                  break;
                }
                case 'CommitCommentEvent': {
                  if (full) add('commitcomment:' + full + ':' + when, 'üó£Ô∏è Commented on a commit in ' + repoLink(full));
                  break;
                }
                case 'IssueCommentEvent': {
                  const n = ev.payload && ev.payload.issue && ev.payload.issue.number;
                  if (full && n != null) {
                    const url = 'https://github.com/' + full + '/issues/' + n;
                    add('issuecomment:' + full + '#' + n + ':' + when, 'üí¨ Commented on ' + issueLink(full, n, url));
                  }
                  break;
                }
                case 'FollowEvent': {
                  const tgt = ev.payload && ev.payload.target && ev.payload.target.login;
                  if (tgt) items.push({ date: when, key: 'follow:' + tgt + ':' + when, text: '‚ûï Followed @' + tgt });
                  break;
                }
                case 'GistEvent': {
                  const a = (ev.payload && ev.payload.action) || 'updated';
                  const gistId = ev.payload && ev.payload.gist && ev.payload.gist.id;
                  const label = a === 'create' ? 'Created' : 'Updated';
                  add('gist:' + a + ':' + (gistId || when), 'üìÑ ' + label + ' a gist' + (gistId ? (' (' + gistId + ')') : ''));
                  break;
                }
                case 'ReleaseEvent': {
                  const tag = ev.payload && ev.payload.release && ev.payload.release.tag_name;
                  if (full && tag) add('release:' + full + ':' + tag + ':' + when, 'üè∑Ô∏è Released `' + tag + '` in ' + repoLink(full));
                  break;
                }
                default:
                  // Skip Push/PR/Issues here to avoid dupes (GraphQL covers your contributions)
                  break;
              }
            }

            // ---- dedupe by key, prefer newest ----
            const map = new Map();
            for (const it of items) {
              if (!it || !it.key || !it.date || !it.text) continue;
              const existing = map.get(it.key);
              if (!existing || new Date(it.date) > new Date(existing.date)) map.set(it.key, it);
            }
            const unique = Array.from(map.values());

            // ---- sort and limit ----
            unique.sort((a,b) => new Date(b.date) - new Date(a.date));
            const lines = unique.slice(0, MAX_LINES).map(i => i.text + '<br>');

            // ---- timestamp (Europe/London) ----
            const ordinal = (n) => {
              const s = ['th','st','nd','rd'], v = n % 100;
              return n + (s[(v - 20) % 10] || s[v] || s[0]);
            };
            const parts = new Intl.DateTimeFormat('en-GB', {
              timeZone: 'Europe/London',
              weekday:'long', month:'long', day:'numeric', year:'numeric',
              hour:'numeric', minute:'2-digit', second:'2-digit', hour12:true
            }).formatToParts(new Date())
              .reduce((a,p) => { a[p.type] = p.value; return a; }, {});
            const dayNum = parseInt(parts.day, 10);
            const lastUpdated = 'Last Updated: '
              + parts.weekday + ', ' + parts.month + ' ' + ordinal(dayNum) + ', ' + parts.year + ', '
              + parts.hour + ':' + parts.minute + ':' + parts.second + ' ' + parts.dayPeriod;

            // ---- inject into README ----
            const inject = (src, start, end, payload) => {
              const i1 = src.indexOf(start), i2 = src.indexOf(end);
              if (i1 === -1 || i2 === -1) return null;
              return src.slice(0, i1 + start.length) + '\n\n' + payload + '\n' + src.slice(i2);
            };

            let md = fs.readFileSync(READ_ME, 'utf8');
            let updated = inject(md, ACT_START, ACT_END, lines.join('\n'));
            if (!updated) core.setFailed('Markers not found: RECENT_ACTIVITY:start/end');

            const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const blockRE = new RegExp(esc(TS_START) + '[\\s\\S]*?' + esc(TS_END), 'm');
            if (blockRE.test(updated)) {
              updated = updated.replace(blockRE, TS_START + '\n\n' + lastUpdated + '\n\n' + TS_END);
            } else {
              core.warning('Timestamp markers not found; skipping last-updated line.');
            }

            if (updated !== md) {
              updated = updated.replace(/^\s*\\n\s*$/gm, '');
              fs.writeFileSync(READ_ME, updated, 'utf8');
              core.notice('README updated with hybrid recent activity.');
            } else {
              core.notice('No README changes were necessary.');
            }

      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "docs: update recent activity"
          file_pattern: README.md
