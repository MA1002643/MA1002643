name: Daily Language Time

on:
  schedule:
    - cron: "0 7 * * *" # 08:00 when London is UTC+1 (BST)
    - cron: "0 8 * * *" # 08:00 when London is UTC+0 (GMT)
  workflow_dispatch: {}

permissions:
  contents: write

env:
  TZ: Europe/London

jobs:
  update-readme:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Ensure Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Build README section from WakaTime (rolling window, Europe/London)
        env:
          WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
          WAKATIME_USER: ${{ secrets.WAKATIME_USER }} # can be unset or empty
        run: |
          python - <<'PY'
          import os, sys, json, datetime, base64, re
          from urllib.request import Request, urlopen
          from urllib.parse import urlencode
          from urllib.error import HTTPError
          from zoneinfo import ZoneInfo

          def hhmm_words(total_seconds:int) -> str:
              m = total_seconds // 60
              h = m // 60
              mm = m % 60
              if h and mm: return f"{h} hrs {mm} mins"
              if h: return f"{h} hrs"
              return f"{mm} mins"

          def percent(secs, total):
              return (secs / total * 100.0) if total else 0.0

          def bar(pct: float, width: int = 25) -> str:
              filled = int(pct / 100 * width + 1e-9)
              return "█" * filled + "░" * (width - filled)

          def fetch_summaries(user: str, api_key: str, start_dt, end_dt):
              params = {
                  "start": start_dt.isoformat(),
                  "end": end_dt.isoformat(),
                  "timezone": "Europe/London",
              }
              url = f"https://wakatime.com/api/v1/users/{user}/summaries?{urlencode(params)}"
              headers = {"Authorization": "Basic " + base64.b64encode(api_key.encode()).decode()}
              with urlopen(Request(url, headers=headers)) as resp:
                  return json.load(resp)

          # --- Strict rolling last 7 days ending "now" (run time) in Europe/London ---
          tz = ZoneInfo("Europe/London")
          now = datetime.datetime.now(tz)
          used_end = now                             # include data up to job run time (08:00)
          used_start = now - datetime.timedelta(days=7)

          # --- Secrets & config ---
          api_key = os.getenv("WAKATIME_API_KEY")
          if not api_key:
              print("::error::WAKATIME_API_KEY secret missing. Add it in repo settings.")
              sys.exit(1)
          user = os.getenv("WAKATIME_USER") or "current"

          # --- Fetch summaries for the 7-day rolling window ---
          try:
              data = fetch_summaries(user, api_key, used_start, used_end)
          except HTTPError as e:
              print(f"::error::WakaTime API error {e.code} at /api/v1/users/{user}/summaries")
              body = e.read().decode(errors="ignore")
              print(body[:500])
              sys.exit(1)

          # --- Aggregate languages across the returned days (partial day included) ---
          def aggregate_langs(summary):
              languages = {}
              for day in summary.get("data", []):
                  for lang in day.get("languages", []):
                      secs = int(lang.get("total_seconds", 0))
                      if secs > 0:
                          name = lang.get("name", "Unknown")
                          languages[name] = languages.get(name, 0) + secs
              return languages

          languages = aggregate_langs(data)
          items = sorted(languages.items(), key=lambda kv: kv[1], reverse=True)

          # --- Build table block ---
          if items:
              total = sum(s for _, s in items)
              name_w = max(12, max(len(n) for n, _ in items))
              time_w, bar_w = 14, 25
              lines = [
                  f"{n.ljust(name_w)}  {hhmm_words(s).ljust(time_w)}  {bar(percent(s,total), bar_w)}   {percent(s,total):05.2f} %"
                  for n, s in items
              ]
              block = "```text\n" + "\n".join(lines) + "\n```"
          else:
              block = "> No editor activity recorded in the selected window."

          # --- Replace README section ---
          start_tag = "<!-- LANG-TIME:START -->"
          end_tag = "<!-- LANG-TIME:END -->"
          with open("README.md","r",encoding="utf-8") as f:
              readme = f.read()
          if start_tag not in readme or end_tag not in readme:
              print("::error::Markers not found in README.md. Add the LANG-TIME markers.")
              sys.exit(1)

          # Footer shows the date corresponding to the run's end instant (date only), and fixed 7 days span
          footer = f"Last updated on {used_end.date().isoformat()} (Displaying Data from past 7 days)"

          replacement = (
              f"{start_tag}\n\n{block}\n\n"
              f"{footer}\n\n"
              f"{end_tag}"
          )

          import re
          new_readme = re.sub(rf"{re.escape(start_tag)}.*?{re.escape(end_tag)}", replacement, readme, flags=re.DOTALL)
          with open("README.md","w",encoding="utf-8") as f:
              f.write(new_readme)
          print("Updated README language time block.")
          PY

      - name: Remove legacy header line from README (optional)
        run: |
          if [ -f README.md ]; then
            sed -i'' '/^Last update: auto at 08:00 AM everyday, showing yesterday$/d' README.md || true
          fi

      - name: Commit & push changes
        run: |
          if git diff --quiet; then
            echo "No changes to commit."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add README.md
          git commit -m "chore: update language time (show today if included; keep 7-day span)"
          git push
